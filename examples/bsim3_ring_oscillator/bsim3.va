/*
 * Verilog-A definition of BSIM3 v3.2.4 
 * Copyright: ASVG Group, ECE Dept, University of Minnesota
 * Auther: Ning Dong, ningd@ece.umn.edu
 *
 * Notes:
 * This code was extracted from BSIM3v3.2.4., released by UC Berkeley.
 * The variable naming convention follows the original C code whenever it is
 * possible. 
 */

//Original Copyright Information 
/**** BSIM3v3.2.4, Released by Xuemei Xi 12/21/2001 ****/
/**********
 * Copyright 2001 Regents of the University of California. All rights reserved.
 * File: b3ld.c of BSIM3v3.2.4
 * Author: 1991 JianHui Huang and Min-Chie Jeng.
 * Modified by Mansun Chan (1995).
 * Author: 1997-1999 Weidong Liu.
 * Author: 2001 Xuemei Xi
 * Modified by Xuemei Xi, 10/05, 12/21, 2001.
 **********/
`include "disciplines.vams"
//`include "constants.vams"
//`include "compact.vams"

// the following constant copied from b3set.c
`define MAX_EXP 5.834617425e+14
`define MIN_EXP 1.713908431e-15
`define EPSOX 3.453133e-11
`define EPSSI 1.03594e-10
`define PI 3.141592654

// the following constant are copied from b3temp.c
`define KboQ 8.617087e-5  /* Kb / q  where q = 1.60219e-19 */
`define EXP_THRESHOLD 34.0
`define Charge_q 1.60219e-19

// the following constant are copied from b3ld.c
`define DELTA_1 0.02
`define DELTA_3 0.02
`define DELTA_4 0.02

`define CONSTroot sqrt(2.0)
`define NOTGIVEN	-9999.9999
`define CKTgmin		1e-12
`define CKTtemp 	(27+273.15)
`define CONSTvt0 0.025864187

module bsim3 (vd, vg, vs, vb);
	inout vd, vg, vs, vb;
	electrical vd, vg, vs, vb, vdp, vsp;

	// The following parameters are extracted from b3.c
	// The default value of these parameters are extracted from b3set.c
	// For those unspecified, set them to `NOTGIVEN
	//
	// device parameter (from BSIM3pTable)
	parameter real l=10e-6;	//Length
	parameter real w=5e-6;	//Width
	parameter real ad=100e-12;	//Drain area
	parameter real as=100e-12;	//Source area
	parameter real pd=40e-6;	//Drain perimeter
	parameter real ps=40e-6;	//Source perimeter
	parameter real nrd=1;	//Number of squares in drain
	parameter real nrs=1;	//Number of squares in source
	parameter integer nqsmod=0;	//Non-quasi-static model selector

	// model parameter (from BSIM3mPTable)
	parameter integer capmod=0;	//Capacitance model selector
	parameter integer mobmod=1;	//Mobility model selector
	parameter integer noimod=1;	//Noise model selector
	parameter integer binunit=1;	//Bin  unit  selector
	parameter real version=3.24;	// parameter for model version
	parameter real tox=1.5e-8;	//Gate oxide thickness in meters
	parameter real toxm=1.5e-8;	//Gate oxide thickness used in extraction
	parameter real cdsc=2.4e-4;	//Drain/Source and channel coupling capacitance
	parameter real cdscb=0.0;	//Body-bias dependence of cdsc
	parameter real cdscd=0.0;	//Drain-bias dependence of cdsc
	parameter real cit=0.0;	//Interface state capacitance
	parameter real nfactor=1.0;	//Subthreshold swing Coefficient
	parameter real xj=0.15e-6;	//Junction depth in meters
	parameter real vsat=8e4;	//Saturation velocity at tnom
	parameter real at=3.3e4;	//Temperature coefficient of vsat
	parameter real a0=1.0;	//Non-uniform depletion width effect coefficient.
	parameter real ags=0.0;	//Gate bias  coefficient of Abulk.
	parameter real a1=0.0;	//Non-saturation effect coefficient
	parameter real a2=1.0;	//Non-saturation effect coefficient
	parameter real keta=-0.047;	//Body-bias coefficient of non-uniform depletion width effect.
	parameter real nsub=6.0e-16;	//Substrate doping concentration
	parameter real nch=1.7e17;	//Channel doping concentration
	parameter real ngate=0;	//Poly-gate doping concentration
	parameter real gamma1=0.0;	//Vth body coefficient
	parameter real gamma2=0.0;	//Vth body coefficient
	parameter real vbx=0.0;	//Vth transition body Voltage
	parameter real vbm=-3.0;	//Maximum body voltage
	parameter real xt=1.55e-7;	//Doping depth
	parameter real k1=`NOTGIVEN;	//Bulk effect coefficient 1
	parameter real kt1=-0.11;	//Temperature coefficient of Vth
	parameter real kt1l=0.0;	//Temperature coefficient of Vth
	parameter real kt2=0.022;	//Body-coefficient of kt1
	parameter real k2=`NOTGIVEN;	//Bulk effect coefficient 2
	parameter real k3=80;	//Narrow width effect coefficient
	parameter real k3b=0.0;	//Body effect coefficient of k3
	parameter real w0=2.5e-6;	//Narrow width effect parameter
	parameter real nlx=1.74e-7;	//Lateral non-uniform doping effect
	parameter real dvt0=2.2;	//Short channel effect coeff. 0
	parameter real dvt1=0.53;	//Short channel effect coeff. 1
	parameter real dvt2=-0.032;	//Short channel effect coeff. 2
	parameter real dvt0w=0.0;	//Narrow Width coeff. 0
	parameter real dvt1w=5.3e6;	//Narrow Width effect coeff. 1
	parameter real dvt2w=-0.032;	//Narrow Width effect coeff. 2
	parameter real drout=0.56;	//DIBL coefficient of output resistance
	parameter real dsub=0.56;	//DIBL coefficient in the subthreshold region
	parameter real vth0=`NOTGIVEN;	//Threshold voltage
	parameter real ua=2.25e-9;	//Linear gate dependence of mobility
	parameter real ua1=4.31e-9;	//Temperature coefficient of ua
	parameter real ub=5.87e-19;	//Quadratic gate dependence of mobility
	parameter real ub1=-7.61e-18;	//Temperature coefficient of ub
	parameter real uc=`NOTGIVEN;	//Body-bias dependence of mobility
	parameter real uc1=`NOTGIVEN;	//Temperature coefficient of uc
	parameter real u0=`NOTGIVEN;	//Low-field mobility at Tn1m
	parameter real ute=-1.5;	//Temperature coefficient of mobility
	parameter real voff=-0.08;	//Threshold voltage offset
	parameter real tnom=0.0;	//Parameter measurement temperature
	parameter real cgso=`NOTGIVEN;	//Gate-source overlap capacitance per width
	parameter real cgdo=`NOTGIVEN;	//Gate-drain overlap capacitance per width
	parameter real cgbo=`NOTGIVEN;	//Gate-bulk overlap capacitance per length
	parameter real xpart=0.0;	//Channel charge partitioning
	parameter real elm=5.0;	//Non-quasi-static Elmore Constant Parameter
	parameter real delta=0.01;	//Effective Vds parameter
	parameter real rsh=0.0;	//Source-drain sheet resistance
	parameter real rdsw=0.0;	//Source-drain resistance per width
	parameter real prwg=0.0;	//Gate-bias effect on parasitic resistance 
	parameter real prwb=0.0;	//Body-effect on parasitic resistance 
	parameter real prt=0.0;	//Temperature coefficient of parasitic resistance 
	parameter real eta0=0.08;	//Subthreshold region DIBL coefficient
	parameter real etab=-0.07;	//Subthreshold region DIBL coefficient
	parameter real pclm=1.3;	//Channel length modulation Coefficient
	parameter real pdiblc1=0.39;	//Drain-induced barrier lowering coefficient
	parameter real pdiblc2=8.6e-3;	//Drain-induced barrier lowering coefficient
	parameter real pdiblcb=0.0;	//Body-effect on drain-induced barrier lowering
	parameter real pscbe1=4.24e8;	//Substrate current body-effect coefficient
	parameter real pscbe2=1e-5;	//Substrate current body-effect coefficient
	parameter real pvag=0.0;	//Gate dependence of output resistance parameter
	parameter real js=1e-4;	//Source/drain junction reverse saturation current density
	parameter real jsw=0.0;	//Sidewall junction reverse saturation current density
	parameter real pb=1.0;	//Source/drain junction built-in potential
	parameter real nj=1.0;	//Source/drain junction emission coefficient
	parameter real xti=3.0;	//Junction current temperature exponent
	parameter real mj=0.5;	//Source/drain bottom junction capacitance grading coefficient
	parameter real pbsw=1.0;	//Source/drain sidewall junction capacitance built in potential
	parameter real mjsw=0.33;	//Source/drain sidewall junction capacitance grading coefficient
	parameter real pbswg=1.0;	//Source/drain (gate side) sidewall junction capacitance built in potential
	parameter real mjswg=0.33;	//Source/drain (gate side) sidewall junction capacitance grading coefficient
	parameter real cj=5e-4;	//Source/drain bottom junction capacitance per unit area
	parameter real vfbcv=-1.0;	//Flat Band Voltage parameter for capmod=0 only
	parameter real vfb=-1;	//Flat Band Voltage
	parameter real cjsw=5e-10;	//Source/drain sidewall junction capacitance per unit periphery
	parameter real cjswg=5e-10;	//Source/drain (gate side) sidewall junction capacitance per unit width
	parameter real tpb=0.0;	//Temperature coefficient of pb
	parameter real tcj=0.0;	//Temperature coefficient of cj
	parameter real tpbsw=0.0;	//Temperature coefficient of pbsw
	parameter real tcjsw=0.0;	//Temperature coefficient of cjsw
	parameter real tpbswg=0.0;	//Temperature coefficient of pbswg
	parameter real tcjswg=0.0;	//Temperature coefficient of cjswg
	parameter real acde1=1.0;	//Exponential coefficient for finite charge thickness
	parameter real moin=15.0;	//Coefficient for gate-bias dependent surface potential
	parameter real noff=1.0;	//C-V turn-on/off parameter
	parameter real voffcv=0.0;	//C-V lateral-shift parameter
	parameter real lint=0.0;	//Length reduction parameter
	parameter real ll=0.0;	//Length reduction parameter
	parameter real llc=0.0;	//Length reduction parameter for CV
	parameter real lln=1.0;	//Length reduction parameter
	parameter real lw=0.0;	//Length reduction parameter
	parameter real lwc=0.0;	//Length reduction parameter for CV
	parameter real lwn=1.0;	//Length reduction parameter
	parameter real lwl=0.0;	//Length reduction parameter
	parameter real lwlc=0.0;	//Length reduction parameter for CV
	parameter real lmin=0.0;	//Minimum length for the model
	parameter real lmax=1.0;	//Maximum length for the model
	parameter real wr=1.0;	//Width dependence of rds
	parameter real wint=0.0;	//Width reduction parameter
	parameter real dwg=0.0;	//Width reduction parameter
	parameter real dwb=0.0;	//Width reduction parameter
	parameter real wl=0.0;	//Width reduction parameter
	parameter real wlc=0.0;	//Width reduction parameter for CV
	parameter real wln=1.0;	//Width reduction parameter
	parameter real ww=0.0;	//Width reduction parameter
	parameter real wwc=0.0;	//Width reduction parameter for CV
	parameter real wwn=1.0;	//Width reduction parameter
	parameter real wwl=0.0;	//Width reduction parameter
	parameter real wwlc=0.0;	//Width reduction parameter for CV
	parameter real wmin=0.0;	//Minimum width for the model
	parameter real wmax=1.0;	//Maximum width for the model
	parameter real b0=0.0;	//Abulk narrow width parameter
	parameter real b1=0.0;	//Abulk narrow width parameter
	parameter real cgsl=0.0;	//New C-V model parameter
	parameter real cgdl=0.0;	//New C-V model parameter
	parameter real ckappa=0.6;	//New C-V model parameter
	parameter real cf=`NOTGIVEN;	//Fringe capacitance parameter
	parameter real clc1=1e-7;	//Vdsat parameter for C-V model
	parameter real cle=0.6;	//Vdsat parameter for C-V model
	parameter real dwc=0.0;	//Delta W for C-V model
	parameter real dlc=`NOTGIVEN;	//Delta L for C-V model
	parameter real alpha0=0.0;	//substrate current model parameter
	parameter real alpha1=0.0;	//substrate current model parameter
	parameter real beta0=30.0;	//substrate current model parameter
	parameter real ijth=0.1;	//Diode limiting current
	parameter real lcdsc=0.0;	//Length dependence of cdsc
	parameter real lcdscb=0.0;	//Length dependence of cdscb
	parameter real lcdscd=0.0;	//Length dependence of cdscd
	parameter real lcit=0.0;	//Length dependence of cit
	parameter real lnfactor=0.0;	//Length dependence of nfactor
	parameter real lxj=0.0;	//Length dependence of xj
	parameter real lvsat=0.0;	//Length dependence of vsat
	parameter real lat=0.0;	//Length dependence of at
	parameter real la0=0.0;	//Length dependence of a0
	parameter real lags=0.0;	//Length dependence of ags
	parameter real la1=0.0;	//Length dependence of a1
	parameter real la2=0.0;	//Length dependence of a2
	parameter real lketa=0.0;	//Length dependence of keta
	parameter real lnsub=0.0;	//Length dependence of nsub
	parameter real lnch=0.0;	//Length dependence of nch
	parameter real lngate=0.0;	//Length dependence of ngate
	parameter real lgamma1=0.0;	//Length dependence of gamma1
	parameter real lgamma2=0.0;	//Length dependence of gamma2
	parameter real lvbx=0.0;	//Length dependence of vbx
	parameter real lvbm=0.0;	//Length dependence of vbm
	parameter real lxt=0.0;	//Length dependence of xt
	parameter real lk1=0.0;	//Length dependence of k1
	parameter real lkt1=0.0;	//Length dependence of kt1
	parameter real lkt1l=0.0;	//Length dependence of kt1l
	parameter real lkt2=0.0;	//Length dependence of kt2
	parameter real lk2=0.0;	//Length dependence of k2
	parameter real lk3=0.0;	//Length dependence of k3
	parameter real lk3b=0.0;	//Length dependence of k3b
	parameter real lw0=0.0;	//Length dependence of w0
	parameter real lnlx=0.0;	//Length dependence of nlx
	parameter real ldvt0=0.0;	//Length dependence of dvt0
	parameter real ldvt1=0.0;	//Length dependence of dvt1
	parameter real ldvt2=0.0;	//Length dependence of dvt2
	parameter real ldvt0w=0.0;	//Length dependence of dvt0w
	parameter real ldvt1w=0.0;	//Length dependence of dvt1w
	parameter real ldvt2w=0.0;	//Length dependence of dvt2w
	parameter real ldrout=0.0;	//Length dependence of drout
	parameter real ldsub=0.0;	//Length dependence of dsub
	parameter real lvth0=0.0;	//Length dependence of vto
	parameter real lua=0.0;	//Length dependence of ua
	parameter real lua1=0.0;	//Length dependence of ua1
	parameter real lub=0.0;	//Length dependence of ub
	parameter real lub1=0.0;	//Length dependence of ub1
	parameter real luc=0.0;	//Length dependence of uc
	parameter real luc1=0.0;	//Length dependence of uc1
	parameter real lu0=0.0;	//Length dependence of u0
	parameter real lute=0.0;	//Length dependence of ute
	parameter real lvoff=0.0;	//Length dependence of voff
	parameter real lelm=0.0;	//Length dependence of elm
	parameter real ldelta=0.0;	//Length dependence of delta
	parameter real lrdsw=0.0;	//Length dependence of rdsw 
	parameter real lprwg=0.0;	//Length dependence of prwg 
	parameter real lprwb=0.0;	//Length dependence of prwb 
	parameter real lprt=0.0;	//Length dependence of prt 
	parameter real leta0=0.0;	//Length dependence of eta0
	parameter real letab=0.0;	//Length dependence of etab
	parameter real lpclm=0.0;	//Length dependence of pclm
	parameter real lpdiblc1=0.0;	//Length dependence of pdiblc1
	parameter real lpdiblc2=0.0;	//Length dependence of pdiblc2
	parameter real lpdiblcb=0.0;	//Length dependence of pdiblcb
	parameter real lpscbe1=0.0;	//Length dependence of pscbe1
	parameter real lpscbe2=0.0;	//Length dependence of pscbe2
	parameter real lpvag=0.0;	//Length dependence of pvag
	parameter real lwr=0.0;	//Length dependence of wr
	parameter real ldwg=0.0;	//Length dependence of dwg
	parameter real ldwb=0.0;	//Length dependence of dwb
	parameter real lb0=0.0;	//Length dependence of b0
	parameter real lb1=0.0;	//Length dependence of b1
	parameter real lcgsl=0.0;	//Length dependence of cgsl
	parameter real lcgdl=0.0;	//Length dependence of cgdl
	parameter real lckappa=0.0;	//Length dependence of ckappa
	parameter real lcf=0.0;	//Length dependence of cf
	parameter real lclc=0.0;	//Length dependence of clc
	parameter real lcle=0.0;	//Length dependence of cle
	parameter real lalpha0=0.0;	//Length dependence of alpha0
	parameter real lalpha1=0.0;	//Length dependence of alpha1
	parameter real lbeta0=0.0;	//Length dependence of beta0
	parameter real lvfbcv=0.0;	//Length dependence of vfbcv
	parameter real lvfb=0.0;	//Length dependence of vfb
	parameter real lacde=0.0;	//Length dependence of acde
	parameter real lmoin=0.0;	//Length dependence of moin
	parameter real lnoff=0.0;	//Length dependence of noff
	parameter real lvoffcv=0.0;	//Length dependence of voffcv
	parameter real wcdsc=0.0;	//Width dependence of cdsc
	parameter real wcdscb=0.0;	//Width dependence of cdscb
	parameter real wcdscd=0.0;	//Width dependence of cdscd
	parameter real wcit=0.0;	//Width dependence of cit
	parameter real wnfactor=0.0;	//Width dependence of nfactor
	parameter real wxj=0.0;	//Width dependence of xj
	parameter real wvsat=0.0;	//Width dependence of vsat
	parameter real wat=0.0;	//Width dependence of at
	parameter real wa0=0.0;	//Width dependence of a0
	parameter real wags=0.0;	//Width dependence of ags
	parameter real wa1=0.0;	//Width dependence of a1
	parameter real wa2=0.0;	//Width dependence of a2
	parameter real wketa=0.0;	//Width dependence of keta
	parameter real wnsub=0.0;	//Width dependence of nsub
	parameter real wnch=0.0;	//Width dependence of nch
	parameter real wngate=0.0;	//Width dependence of ngate
	parameter real wgamma1=0.0;	//Width dependence of gamma1
	parameter real wgamma2=0.0;	//Width dependence of gamma2
	parameter real wvbx=0.0;	//Width dependence of vbx
	parameter real wvbm=0.0;	//Width dependence of vbm
	parameter real wxt=0.0;	//Width dependence of xt
	parameter real wk1=0.0;	//Width dependence of k1
	parameter real wkt1=0.0;	//Width dependence of kt1
	parameter real wkt1l=0.0;	//Width dependence of kt1l
	parameter real wkt2=0.0;	//Width dependence of kt2
	parameter real wk2=0.0;	//Width dependence of k2
	parameter real wk3=0.0;	//Width dependence of k3
	parameter real wk3b=0.0;	//Width dependence of k3b
	parameter real ww0=0.0;	//Width dependence of w0
	parameter real wnlx=0.0;	//Width dependence of nlx
	parameter real wdvt0=0.0;	//Width dependence of dvt0
	parameter real wdvt1=0.0;	//Width dependence of dvt1
	parameter real wdvt2=0.0;	//Width dependence of dvt2
	parameter real wdvt0w=0.0;	//Width dependence of dvt0w
	parameter real wdvt1w=0.0;	//Width dependence of dvt1w
	parameter real wdvt2w=0.0;	//Width dependence of dvt2w
	parameter real wdrout=0.0;	//Width dependence of drout
	parameter real wdsub=0.0;	//Width dependence of dsub
	parameter real wvth0=0.0;	//Width dependence of vto
	parameter real wua=0.0;	//Width dependence of ua
	parameter real wua1=0.0;	//Width dependence of ua1
	parameter real wub=0.0;	//Width dependence of ub
	parameter real wub1=0.0;	//Width dependence of ub1
	parameter real wuc=0.0;	//Width dependence of uc
	parameter real wuc1=0.0;	//Width dependence of uc1
	parameter real wu0=0.0;	//Width dependence of u0
	parameter real wute=0.0;	//Width dependence of ute
	parameter real wvoff=0.0;	//Width dependence of voff
	parameter real welm=0.0;	//Width dependence of elm
	parameter real wdelta=0.0;	//Width dependence of delta
	parameter real wrdsw=0.0;	//Width dependence of rdsw 
	parameter real wprwg=0.0;	//Width dependence of prwg 
	parameter real wprwb=0.0;	//Width dependence of prwb 
	parameter real wprt=0.0;	//Width dependence of prt
	parameter real weta0=0.0;	//Width dependence of eta0
	parameter real wetab=0.0;	//Width dependence of etab
	parameter real wpclm=0.0;	//Width dependence of pclm
	parameter real wpdiblc1=0.0;	//Width dependence of pdiblc1
	parameter real wpdiblc2=0.0;	//Width dependence of pdiblc2
	parameter real wpdiblcb=0.0;	//Width dependence of pdiblcb
	parameter real wpscbe1=0.0;	//Width dependence of pscbe1
	parameter real wpscbe2=0.0;	//Width dependence of pscbe2
	parameter real wpvag=0.0;	//Width dependence of pvag
	parameter real wwr=0.0;	//Width dependence of wr
	parameter real wdwg=0.0;	//Width dependence of dwg
	parameter real wdwb=0.0;	//Width dependence of dwb
	parameter real wb0=0.0;	//Width dependence of b0
	parameter real wb1=0.0;	//Width dependence of b1
	parameter real wcgsl=0.0;	//Width dependence of cgsl
	parameter real wcgdl=0.0;	//Width dependence of cgdl
	parameter real wckappa=0.0;	//Width dependence of ckappa
	parameter real wcf=0.0;	//Width dependence of cf
	parameter real wclc=0.0;	//Width dependence of clc
	parameter real wcle=0.0;	//Width dependence of cle
	parameter real walpha0=0.0;	//Width dependence of alpha0
	parameter real walpha1=0.0;	//Width dependence of alpha1
	parameter real wbeta0=0.0;	//Width dependence of beta0
	parameter real wvfbcv=0.0;	//Width dependence of vfbcv
	parameter real wvfb=0.0;	//Width dependence of vfb
	parameter real wacde=0.0;	//Width dependence of acde
	parameter real wmoin=0.0;	//Width dependence of moin
	parameter real wnoff=0.0;	//Width dependence of noff
	parameter real wvoffcv=0.0;	//Width dependence of voffcv
	parameter real pcdsc=0.0;	//Cross-term dependence of cdsc
	parameter real pcdscb=0.0;	//Cross-term dependence of cdscb
	parameter real pcdscd=0.0;	//Cross-term dependence of cdscd
	parameter real pcit=0.0;	//Cross-term dependence of cit
	parameter real pnfactor=0.0;	//Cross-term dependence of nfactor
	parameter real pxj=0.0;	//Cross-term dependence of xj
	parameter real pvsat=0.0;	//Cross-term dependence of vsat
	parameter real pat=0.0;	//Cross-term dependence of at
	parameter real pa0=0.0;	//Cross-term dependence of a0
	parameter real pags=0.0;	//Cross-term dependence of ags
	parameter real pa1=0.0;	//Cross-term dependence of a1
	parameter real pa2=0.0;	//Cross-term dependence of a2
	parameter real pketa=0.0;	//Cross-term dependence of keta
	parameter real pnsub=0.0;	//Cross-term dependence of nsub
	parameter real pnch=0.0;	//Cross-term dependence of nch
	parameter real pngate=0.0;	//Cross-term dependence of ngate
	parameter real pgamma1=0.0;	//Cross-term dependence of gamma1
	parameter real pgamma2=0.0;	//Cross-term dependence of gamma2
	parameter real pvbx=0.0;	//Cross-term dependence of vbx
	parameter real pvbm=0.0;	//Cross-term dependence of vbm
	parameter real pxt=0.0;	//Cross-term dependence of xt
	parameter real pk1=0.0;	//Cross-term dependence of k1
	parameter real pkt1=0.0;	//Cross-term dependence of kt1
	parameter real pkt1l=0.0;	//Cross-term dependence of kt1l
	parameter real pkt2=0.0;	//Cross-term dependence of kt2
	parameter real pk2=0.0;	//Cross-term dependence of k2
	parameter real pk3=0.0;	//Cross-term dependence of k3
	parameter real pk3b=0.0;	//Cross-term dependence of k3b
	parameter real pw0=0.0;	//Cross-term dependence of w0
	parameter real pnlx=0.0;	//Cross-term dependence of nlx
	parameter real pdvt0=0.0;	//Cross-term dependence of dvt0
	parameter real pdvt1=0.0;	//Cross-term dependence of dvt1
	parameter real pdvt2=0.0;	//Cross-term dependence of dvt2
	parameter real pdvt0w=0.0;	//Cross-term dependence of dvt0w
	parameter real pdvt1w=0.0;	//Cross-term dependence of dvt1w
	parameter real pdvt2w=0.0;	//Cross-term dependence of dvt2w
	parameter real pdrout=0.0;	//Cross-term dependence of drout
	parameter real pdsub=0.0;	//Cross-term dependence of dsub
	parameter real pvth0=0.0;	//Cross-term dependence of vto
	parameter real pua=0.0;	//Cross-term dependence of ua
	parameter real pua1=0.0;	//Cross-term dependence of ua1
	parameter real pub=0.0;	//Cross-term dependence of ub
	parameter real pub1=0.0;	//Cross-term dependence of ub1
	parameter real puc=0.0;	//Cross-term dependence of uc
	parameter real puc1=0.0;	//Cross-term dependence of uc1
	parameter real pu0=0.0;	//Cross-term dependence of u0
	parameter real pute=0.0;	//Cross-term dependence of ute
	parameter real pvoff=0.0;	//Cross-term dependence of voff
	parameter real pelm=0.0;	//Cross-term dependence of elm
	parameter real pdelta=0.0;	//Cross-term dependence of delta
	parameter real prdsw=0.0;	//Cross-term dependence of rdsw 
	parameter real pprwg=0.0;	//Cross-term dependence of prwg 
	parameter real pprwb=0.0;	//Cross-term dependence of prwb 
	parameter real pprt=0.0;	//Cross-term dependence of prt 
	parameter real peta0=0.0;	//Cross-term dependence of eta0
	parameter real petab=0.0;	//Cross-term dependence of etab
	parameter real ppclm=0.0;	//Cross-term dependence of pclm
	parameter real ppdiblc1=0.0;	//Cross-term dependence of pdiblc1
	parameter real ppdiblc2=0.0;	//Cross-term dependence of pdiblc2
	parameter real ppdiblcb=0.0;	//Cross-term dependence of pdiblcb
	parameter real ppscbe1=0.0;	//Cross-term dependence of pscbe1
	parameter real ppscbe2=0.0;	//Cross-term dependence of pscbe2
	parameter real ppvag=0.0;	//Cross-term dependence of pvag
	parameter real pwr=0.0;	//Cross-term dependence of wr
	parameter real pdwg=0.0;	//Cross-term dependence of dwg
	parameter real pdwb=0.0;	//Cross-term dependence of dwb
	parameter real pb0=0.0;	//Cross-term dependence of b0
	parameter real pb1=0.0;	//Cross-term dependence of b1
	parameter real pcgsl=0.0;	//Cross-term dependence of cgsl
	parameter real pcgdl=0.0;	//Cross-term dependence of cgdl
	parameter real pckappa=0.0;	//Cross-term dependence of ckappa
	parameter real pcf=0.0;	//Cross-term dependence of cf
	parameter real pclc=0.0;	//Cross-term dependence of clc
	parameter real pcle=0.0;	//Cross-term dependence of cle
	parameter real palpha0=0.0;	//Cross-term dependence of alpha0
	parameter real palpha1=0.0;	//Cross-term dependence of alpha1
	parameter real pbeta0=0.0;	//Cross-term dependence of beta0
	parameter real pvfbcv=0.0;	//Cross-term dependence of vfbcv
	parameter real pvfb=0.0;	//Cross-term dependence of vfb
	parameter real pacde=0.0;	//Cross-term dependence of acde
	parameter real pmoin=0.0;	//Cross-term dependence of moin
	parameter real pnoff=0.0;	//Cross-term dependence of noff
	parameter real pvoffcv=0.0;	//Cross-term dependence of voffcv
	parameter real noia=1e20;	//Flicker noise parameter
	parameter real noib=5e4;	//Flicker noise parameter
	parameter real noic=-1.4e-12;	//Flicker noise parameter
	parameter real em=4.1e7;	//Flicker noise parameter
	parameter real ef=1.0;	//Flicker noise frequency exponent
	parameter real af=1.0;	//Flicker noise exponent
	parameter real kf=0.0;	//Flicker noise coefficient
	parameter integer Type=0;	// 1 for nmos, -1 for pmos
	//============ End of Parameters ================================

	//============ Local variable begins ============================
	//These are copied from b3ld.c
	//Some variables conflict with the parameters above. They are
	//voffcv, noff, a1, cgdo, cgso. Change their name to LOCAL_xxx.
	//TODO: some variables are used to calculate derivative. Delete 
	//them later.
	real SourceSatCurrent, DrainSatCurrent;
	real qgd, qgs, qgb, VgstNVt, ExpVgst;
	real cdreq, ceqbd, ceqbs;
	real czbd, czbdsw, czbdswg, czbs, czbssw, czbsswg, evbd, evbs, arg, sarg;
	real Vfbeff, V3, V4;
	real MJ, MJSW, MJSWG;
	real vbd, vbs, vds, vgb, vgd, vgs;
	real qgate, qbulk, qdrn, qsrc, qinoi;
	real Vds, Vgs, Vbs;
	real Vgs_eff, Vfb;
	real Phis, sqrtPhis,dsqrtPhis_dVb, Vth;
	real Vgst, Nvtm;
	real Vtm;
	real n, LOCAL_voffcv, LOCAL_noff;
	real ExpArg, V0, CoxWLcen, LINK;
	real DeltaPhi;
	real Cox, Tox, Tcen;
	real Ccen, Coxeff;
	real Denomi;
	real ueff; 
	real Esat, Vdsat;
	real EsatL;
	real Vasat; 
	real Va; 
	real Vbseff,VbseffCV; 
	real Arg1, One_Third_CoxWL, Two_Third_CoxWL, Alphaz, CoxWL; 
	real T0;
	real T1, dT1_dVb;
	real T2, dT2_dVg;
	real T3;
	real T4;
	real T5;
	real T6;
	real T7;
	real T8;
	real T9;
	real T10; 
	real tmp, Abulk, Abulk0;
	real VACLM;
	real VADIBL;
	real Xdep, lt1, ltw, Delt_vth;
	real Theta0;
	real TempRatio, tmp1, tmp2, tmp3, tmp4;
	real DIBL_Sft,dDIBL_Sft_dVd, Lambda;

	real Vgsteff; 
	real Vdseff; 
	real VdseffCV; 
	real diffVds, dAbulk_dVg;
	real beta;
	real gche;
	real fgche1;
	real fgche2;
	real Idl;
	real Idsa;
	real Ids, Isub;
	real VASCBE;
	real CoxWovL;
	real Rds, WVCox, WVCoxRds;
	real Vgst2Vtm, VdsatCV;
	real Leff, Weff, AbulkCV;
	real qgdo, qgso, LOCAL_cgdo, LOCAL_cgso;
	real Qac0, Qsub0;
	   
	//struct bsim3SizeDependParam *pParam;
	//========== End of Copy ====================================
	
	//========== Copy from bsim3def.h sBSIM3instance ============
	//TODO/FIX: not all of these are used 

    /* MCJ */
    real BSIM3ueff;
    real BSIM3thetavth; 
    real BSIM3von;
    real BSIM3vdsat;
    real BSIM3cgdo;
    real BSIM3cgso;
    real BSIM3vjsm;
    real BSIM3IsEvjsm;
    real BSIM3vjdm;
    real BSIM3IsEvjdm;

    real BSIM3l;
    real BSIM3w;
    real BSIM3drainArea;
    real BSIM3sourceArea;
    real BSIM3drainSquares;
    real BSIM3sourceSquares;
    real BSIM3drainPerimeter;
    real BSIM3sourcePerimeter;
    real BSIM3sourceConductance;
    real BSIM3drainConductance;

    integer BSIM3mode;
    integer BSIM3nqsMod;

    /* OP point */
    real BSIM3qinv;
    real BSIM3cbs;
    real BSIM3cbd;
    real BSIM3gbd;

    real BSIM3rds;  /* Noise bugfix */
    real BSIM3Vgsteff;
    real BSIM3Vdseff;
    real BSIM3Abulk;
    real BSIM3AbovVgst2Vtm;
	//========= end of Copy ==========================
	
	//========= Copy from bsim3def.h (bsim3SizeDependParam)============
	//TODO/FIXME: not all of these are used 
	real Width;
    real Length;

    real BSIM3cdsc;           
    real BSIM3cdscb;    
    real BSIM3cdscd;       
    real BSIM3cit;           
    real BSIM3nfactor;      
    real BSIM3xj;
    real BSIM3vsat;         
    real BSIM3at;         
    real BSIM3a0;   
    real BSIM3ags;      
    real BSIM3a1;         
    real BSIM3a2;         
    real BSIM3keta;     
    real BSIM3nsub;
    real BSIM3npeak;        
    real BSIM3ngate;        
    real BSIM3gamma1;      
    real BSIM3gamma2;     
    real BSIM3vbx;      
    real BSIM3vbi;       
    real BSIM3vbm;       
    real BSIM3vbsc;       
    real BSIM3xt;       
    real BSIM3phi;
    real BSIM3litl;
    real BSIM3k1;
    real BSIM3kt1;
    real BSIM3kt1l;
    real BSIM3kt2;
    real BSIM3k2;
    real BSIM3k3;
    real BSIM3k3b;
    real BSIM3w0;
    real BSIM3nlx;
    real BSIM3dvt0;      
    real BSIM3dvt1;      
    real BSIM3dvt2;      
    real BSIM3dvt0w;      
    real BSIM3dvt1w;      
    real BSIM3dvt2w;      
    real BSIM3drout;      
    real BSIM3dsub;      
    real BSIM3vth0;
    real BSIM3ua;
    real BSIM3ua1;
    real BSIM3ub;
    real BSIM3ub1;
    real BSIM3uc;
    real BSIM3uc1;
    real BSIM3u0;
    real BSIM3ute;
    real BSIM3voff;
    real BSIM3vfb;
    real BSIM3delta;
    real BSIM3rdsw;       
    real BSIM3rds0;       
    real BSIM3prwg;       
    real BSIM3prwb;       
    real BSIM3prt;       
    real BSIM3eta0;         
    real BSIM3etab;         
    real BSIM3pclm;      
    real BSIM3pdibl1;      
    real BSIM3pdibl2;      
    real BSIM3pdiblb;      
    real BSIM3pscbe1;       
    real BSIM3pscbe2;       
    real BSIM3pvag;       
    real BSIM3wr;
    real BSIM3dwg;
    real BSIM3dwb;
    real BSIM3b0;
    real BSIM3b1;
    real BSIM3alpha0;
    real BSIM3alpha1;
    real BSIM3beta0;


    /* CV model */
    real BSIM3elm;
    real BSIM3cgsl;
    real BSIM3cgdl;
    real BSIM3ckappa;
    real BSIM3cf;
    real BSIM3clc;
    real BSIM3cle;
    real BSIM3vfbcv;
    real BSIM3noff;
    real BSIM3voffcv;
    real BSIM3acde;
    real BSIM3moin;


/* Pre-calculated constants */

    real BSIM3dw;
    real BSIM3dl;
    real BSIM3leff;
    real BSIM3weff;

    real BSIM3dwc;
    real BSIM3dlc;
    real BSIM3leffCV;
    real BSIM3weffCV;
    real BSIM3abulkCVfactor;
    real BSIM3cgbo;
    real BSIM3tconst;

    real BSIM3u0temp;       
    real BSIM3vsattemp;   
    real BSIM3sqrtPhi;   
    real BSIM3phis3;   
    real BSIM3Xdep0;          
    real BSIM3sqrtXdep0;          
    real BSIM3theta0vb0;
    real BSIM3thetaRout; 

    real BSIM3cdep0;
    real BSIM3vfbzb;
    real BSIM3ldeb;
    real BSIM3k1ox;
    real BSIM3k2ox;
	// ======== end of Copy
	
	//========== copy from bsim3def.h (sBSIM3model)======
	//lots of these have been declared above.
    integer    BSIM3mobMod;
    integer    BSIM3capMod;
    integer    BSIM3noiMod;
    integer    BSIM3binUnit;
    real BSIM3version;             
    real BSIM3tox;             
    real BSIM3toxm;
	real BSIM3tcj;
    real BSIM3tcjsw;
    real BSIM3tcjswg;
    real BSIM3tpb;
    real BSIM3tpbsw;
    real BSIM3tpbswg;

    /* Length Dependence */
    real BSIM3lcdsc;           
    real BSIM3lcdscb; 
    real BSIM3lcdscd;          
    real BSIM3lcit;           
    real BSIM3lnfactor;      
    real BSIM3lxj;
    real BSIM3lvsat;         
    real BSIM3lat;         
    real BSIM3la0;   
    real BSIM3lags;      
    real BSIM3la1;         
    real BSIM3la2;         
    real BSIM3lketa;     
    real BSIM3lnsub;
    real BSIM3lnpeak;        
    real BSIM3lngate;        
    real BSIM3lgamma1;      
    real BSIM3lgamma2;     
    real BSIM3lvbx;      
    real BSIM3lvbm;       
    real BSIM3lxt;       
    real BSIM3lk1;
    real BSIM3lkt1;
    real BSIM3lkt1l;
    real BSIM3lkt2;
    real BSIM3lk2;
    real BSIM3lk3;
    real BSIM3lk3b;
    real BSIM3lw0;
    real BSIM3lnlx;
    real BSIM3ldvt0;      
    real BSIM3ldvt1;      
    real BSIM3ldvt2;      
    real BSIM3ldvt0w;      
    real BSIM3ldvt1w;      
    real BSIM3ldvt2w;      
    real BSIM3ldrout;      
    real BSIM3ldsub;      
    real BSIM3lvth0;
    real BSIM3lua;
    real BSIM3lua1;
    real BSIM3lub;
    real BSIM3lub1;
    real BSIM3luc;
    real BSIM3luc1;
    real BSIM3lu0;
    real BSIM3lute;
    real BSIM3lvoff;
    real BSIM3ldelta;
    real BSIM3lrdsw;       
    real BSIM3lprwg;
    real BSIM3lprwb;
    real BSIM3lprt;       
    real BSIM3leta0;         
    real BSIM3letab;         
    real BSIM3lpclm;      
    real BSIM3lpdibl1;      
    real BSIM3lpdibl2;      
    real BSIM3lpdiblb;
    real BSIM3lpscbe1;       
    real BSIM3lpscbe2;       
    real BSIM3lpvag;       
    real BSIM3lwr;
    real BSIM3ldwg;
    real BSIM3ldwb;
    real BSIM3lb0;
    real BSIM3lb1;
    real BSIM3lalpha0;
    real BSIM3lalpha1;
    real BSIM3lbeta0;
    real BSIM3lvfb;

    /* CV model */
    real BSIM3lelm;
    real BSIM3lcgsl;
    real BSIM3lcgdl;
    real BSIM3lckappa;
    real BSIM3lcf;
    real BSIM3lclc;
    real BSIM3lcle;
    real BSIM3lvfbcv;
    real BSIM3lnoff;
    real BSIM3lvoffcv;
    real BSIM3lacde;
    real BSIM3lmoin;

    /* Width Dependence */
    real BSIM3wcdsc;           
    real BSIM3wcdscb; 
    real BSIM3wcdscd;          
    real BSIM3wcit;           
    real BSIM3wnfactor;      
    real BSIM3wxj;
    real BSIM3wvsat;         
    real BSIM3wat;         
    real BSIM3wa0;   
    real BSIM3wags;      
    real BSIM3wa1;         
    real BSIM3wa2;         
    real BSIM3wketa;     
    real BSIM3wnsub;
    real BSIM3wnpeak;        
    real BSIM3wngate;        
    real BSIM3wgamma1;      
    real BSIM3wgamma2;     
    real BSIM3wvbx;      
    real BSIM3wvbm;       
    real BSIM3wxt;       
    real BSIM3wk1;
    real BSIM3wkt1;
    real BSIM3wkt1l;
    real BSIM3wkt2;
    real BSIM3wk2;
    real BSIM3wk3;
    real BSIM3wk3b;
    real BSIM3ww0;
    real BSIM3wnlx;
    real BSIM3wdvt0;      
    real BSIM3wdvt1;      
    real BSIM3wdvt2;      
    real BSIM3wdvt0w;      
    real BSIM3wdvt1w;      
    real BSIM3wdvt2w;      
    real BSIM3wdrout;      
    real BSIM3wdsub;      
    real BSIM3wvth0;
    real BSIM3wua;
    real BSIM3wua1;
    real BSIM3wub;
    real BSIM3wub1;
    real BSIM3wuc;
    real BSIM3wuc1;
    real BSIM3wu0;
    real BSIM3wute;
    real BSIM3wvoff;
    real BSIM3wdelta;
    real BSIM3wrdsw;       
    real BSIM3wprwg;
    real BSIM3wprwb;
    real BSIM3wprt;       
    real BSIM3weta0;         
    real BSIM3wetab;         
    real BSIM3wpclm;      
    real BSIM3wpdibl1;      
    real BSIM3wpdibl2;      
    real BSIM3wpdiblb;
    real BSIM3wpscbe1;       
    real BSIM3wpscbe2;       
    real BSIM3wpvag;       
    real BSIM3wwr;
    real BSIM3wdwg;
    real BSIM3wdwb;
    real BSIM3wb0;
    real BSIM3wb1;
    real BSIM3walpha0;
    real BSIM3walpha1;
    real BSIM3wbeta0;
    real BSIM3wvfb;

    /* CV model */
    real BSIM3welm;
    real BSIM3wcgsl;
    real BSIM3wcgdl;
    real BSIM3wckappa;
    real BSIM3wcf;
    real BSIM3wclc;
    real BSIM3wcle;
    real BSIM3wvfbcv;
    real BSIM3wnoff;
    real BSIM3wvoffcv;
    real BSIM3wacde;
    real BSIM3wmoin;

    /* Cross-term Dependence */
    real BSIM3pcdsc;           
    real BSIM3pcdscb; 
    real BSIM3pcdscd;          
    real BSIM3pcit;           
    real BSIM3pnfactor;      
    real BSIM3pxj;
    real BSIM3pvsat;         
    real BSIM3pat;         
    real BSIM3pa0;   
    real BSIM3pags;      
    real BSIM3pa1;         
    real BSIM3pa2;         
    real BSIM3pketa;     
    real BSIM3pnsub;
    real BSIM3pnpeak;        
    real BSIM3pngate;        
    real BSIM3pgamma1;      
    real BSIM3pgamma2;     
    real BSIM3pvbx;      
    real BSIM3pvbm;       
    real BSIM3pxt;       
    real BSIM3pk1;
    real BSIM3pkt1;
    real BSIM3pkt1l;
    real BSIM3pkt2;
    real BSIM3pk2;
    real BSIM3pk3;
    real BSIM3pk3b;
    real BSIM3pw0;
    real BSIM3pnlx;
    real BSIM3pdvt0;      
    real BSIM3pdvt1;      
    real BSIM3pdvt2;      
    real BSIM3pdvt0w;      
    real BSIM3pdvt1w;      
    real BSIM3pdvt2w;      
    real BSIM3pdrout;      
    real BSIM3pdsub;      
    real BSIM3pvth0;
    real BSIM3pua;
    real BSIM3pua1;
    real BSIM3pub;
    real BSIM3pub1;
    real BSIM3puc;
    real BSIM3puc1;
    real BSIM3pu0;
    real BSIM3pute;
    real BSIM3pvoff;
    real BSIM3pdelta;
    real BSIM3prdsw;
    real BSIM3pprwg;
    real BSIM3pprwb;
    real BSIM3pprt;       
    real BSIM3peta0;         
    real BSIM3petab;         
    real BSIM3ppclm;      
    real BSIM3ppdibl1;      
    real BSIM3ppdibl2;      
    real BSIM3ppdiblb;
    real BSIM3ppscbe1;       
    real BSIM3ppscbe2;       
    real BSIM3ppvag;       
    real BSIM3pwr;
    real BSIM3pdwg;
    real BSIM3pdwb;
    real BSIM3pb0;
    real BSIM3pb1;
    real BSIM3palpha0;
    real BSIM3palpha1;
    real BSIM3pbeta0;
    real BSIM3pvfb;

    /* CV model */
    real BSIM3pelm;
    real BSIM3pcgsl;
    real BSIM3pcgdl;
    real BSIM3pckappa;
    real BSIM3pcf;
    real BSIM3pclc;
    real BSIM3pcle;
    real BSIM3pvfbcv;
    real BSIM3pnoff;
    real BSIM3pvoffcv;
    real BSIM3pacde;
    real BSIM3pmoin;

    real BSIM3tnom;
    real BSIM3xpart;

    real BSIM3sheetResistance;
    real BSIM3jctSatCurDensity;
    real BSIM3jctSidewallSatCurDensity;
    real BSIM3bulkJctPotential;
    real BSIM3bulkJctBotGradingCoeff;
    real BSIM3bulkJctSideGradingCoeff;
    real BSIM3bulkJctGateSideGradingCoeff;
    real BSIM3sidewallJctPotential;
    real BSIM3GatesidewallJctPotential;
    real BSIM3unitAreaJctCap;
    real BSIM3unitLengthSidewallJctCap;
    real BSIM3unitLengthGateSidewallJctCap;
    real BSIM3jctEmissionCoeff;
    real BSIM3jctTempExponent;

    real BSIM3Lint;
    real BSIM3Ll;
    real BSIM3Llc;
    real BSIM3Lln;
    real BSIM3Lw;
    real BSIM3Lwc;
    real BSIM3Lwn;
    real BSIM3Lwl;
    real BSIM3Lwlc;
    real BSIM3Lmin;
    real BSIM3Lmax;

    real BSIM3Wint;
    real BSIM3Wl;
    real BSIM3Wlc;
    real BSIM3Wln;
    real BSIM3Ww;
    real BSIM3Wwc;
    real BSIM3Wwn;
    real BSIM3Wwl;
    real BSIM3Wwlc;
    real BSIM3Wmin;
    real BSIM3Wmax;


/* Pre-calculated constants */
    /* MCJ: move to size-dependent param. */
    real BSIM3vtm;   
    real BSIM3cox;
    real BSIM3vcrit;
    real BSIM3factor1;
    real BSIM3PhiB;
    real BSIM3PhiBSW;
    real BSIM3PhiBSWG;
    real BSIM3jctTempSatCurDensity;
    real BSIM3jctSidewallTempSatCurDensity;
    real BSIM3unitAreaTempJctCap;
    real BSIM3unitLengthSidewallTempJctCap;
    real BSIM3unitLengthGateSidewallTempJctCap;

    real BSIM3oxideTrapDensityA;      
    real BSIM3oxideTrapDensityB;     
    real BSIM3oxideTrapDensityC;  
    real BSIM3em;  
    real BSIM3ef;  
    real BSIM3af;  
    real BSIM3kf;  

	//new added local variables
	real BSIM3ijth;
	real BSIM3type;
	real Tnom, TRatio, Temp, Vtm0, Eg0, ni, Eg, delTemp, Ldrn, Wdrn;
	real Inv_L, Inv_W, Inv_LW;
	real BSIM3qbs;
	//used in source/bulk, drain bulk jct charge
	real BSIM3qbd;

	//these flags are necessary
	integer BSIM3k1Given;
	integer BSIM3k2Given;
	integer BSIM3nsubGiven;
	integer BSIM3xtGiven;
	integer BSIM3vbxGiven;
	integer BSIM3gamma1Given;
	integer BSIM3gamma2Given;
	integer BSIM3vfbGiven;
	integer BSIM3vth0Given;
	integer BSIM3dlcGiven;

	//These are desired output of DAEs
	//real Qgate, Qdrain, Qsource, Qbulk, Qdrainp, Qsourcep;
	//real Igate, Idrain, Isource, Ibulk, Idrainp, Isourcep;
	//These are branch currents
	//real I_drain_drainp;
	//real I_source_sourcep=0.0;
	//real I_drainp_sourcep=0.0;	//Ids
	//real I_bulk_drainp=0.0;
	//real I_bulk_sourcep=0.0;
		
	real vd_vdp, vs_vsp;
	////////////////////////////////////////////////////
	//
	// BSIM3 equation extraction begins (section 1)
	//
	///////////////////////////////////////////////////
	
	analog 
		begin

		// Setup parameter: refer to b3set.c
		BSIM3drainArea = ad;
		BSIM3sourceArea = as;
		BSIM3drainSquares = nrd;
		BSIM3sourceSquares = nrs;
		BSIM3drainPerimeter = pd;
		BSIM3sourcePerimeter = ps;
		
		// The follow paragraph are generated by python scripts 
		// refer to: b3set.c b3mpar.c
		BSIM3mobMod = mobmod;
		BSIM3binUnit = binunit;
		BSIM3capMod = capmod;
		BSIM3noiMod = noimod;
		BSIM3version = version;
		BSIM3tox = tox;
		//toxm=tox;
		BSIM3toxm = toxm;
		BSIM3cdsc = cdsc;
		BSIM3cdscb = cdscb;
		BSIM3cdscd = cdscd;
		BSIM3cit = cit;
		BSIM3nfactor = nfactor;
		BSIM3xj = xj;
		BSIM3vsat = vsat;
		BSIM3a0 = a0;
		BSIM3ags = ags;
		BSIM3a1 = a1;
		BSIM3a2 = a2;
		BSIM3at = at;
		BSIM3keta = keta;
		BSIM3nsub = nsub;
		BSIM3npeak = nch;
		BSIM3ngate = ngate;
		BSIM3gamma1 = gamma1;
		BSIM3gamma2 = gamma2;
		BSIM3vbx = vbx;
		BSIM3vbm = vbm;
		BSIM3xt = xt;
		BSIM3k1 = k1;
		BSIM3kt1 = kt1;
		BSIM3kt1l = kt1l;
		BSIM3kt2 = kt2;
		BSIM3k2 = k2;
		BSIM3k3 = k3;
		BSIM3k3b = k3b;
		BSIM3nlx = nlx;
		BSIM3w0 = w0;
		BSIM3dvt0 = dvt0;
		BSIM3dvt1 = dvt1;
		BSIM3dvt2 = dvt2;
		BSIM3dvt0w = dvt0w;
		BSIM3dvt1w = dvt1w;
		BSIM3dvt2w = dvt2w;
		BSIM3drout = drout;
		BSIM3dsub = dsub;
		BSIM3vth0 = vth0;	//change from vtho to vth0
		BSIM3ua = ua;
		BSIM3ua1 = ua1;
		BSIM3ub = ub;
		BSIM3ub1 = ub1;
		BSIM3uc = uc;
		BSIM3uc1 = uc1;
		BSIM3u0 = u0;
		BSIM3ute = ute;
		BSIM3voff = voff;
		BSIM3delta = delta;
		BSIM3rdsw = rdsw;
		BSIM3prwg = prwg;
		BSIM3prwb = prwb;
		BSIM3prt = prt;
		BSIM3eta0 = eta0;
		BSIM3etab = etab;
		BSIM3pclm = pclm;
		BSIM3pdibl1 = pdiblc1;
		BSIM3pdibl2 = pdiblc2;
		BSIM3pdiblb = pdiblcb;
		BSIM3pscbe1 = pscbe1;
		BSIM3pscbe2 = pscbe2;
		BSIM3pvag = pvag;
		BSIM3wr = wr;
		BSIM3dwg = dwg;
		BSIM3dwb = dwb;
		BSIM3b0 = b0;
		BSIM3b1 = b1;
		BSIM3alpha0 = alpha0;
		BSIM3alpha1 = alpha1;
		BSIM3beta0 = beta0;
		BSIM3ijth = ijth;
		BSIM3vfb = vfb;
		BSIM3elm = elm;
		BSIM3cgsl = cgsl;
		BSIM3cgdl = cgdl;
		BSIM3ckappa = ckappa;
		BSIM3cf = cf;
		BSIM3clc = clc1;
		BSIM3cle = cle;
		BSIM3dwc = dwc;
		BSIM3dlc = dlc;
		BSIM3vfbcv = vfbcv;
		BSIM3acde = acde1;
		BSIM3moin = moin;
		BSIM3noff = noff;
		BSIM3voffcv = voffcv;
		BSIM3tcj = tcj;
		BSIM3tpb = tpb;
		BSIM3tcjsw = tcjsw;
		BSIM3tpbsw = tpbsw;
		BSIM3tcjswg = tcjswg;
		BSIM3tpbswg = tpbswg;
		BSIM3lcdsc = lcdsc;
		BSIM3lcdscb = lcdscb;
		BSIM3lcdscd = lcdscd;
		BSIM3lcit = lcit;
		BSIM3lnfactor = lnfactor;
		BSIM3lxj = lxj;
		BSIM3lvsat = lvsat;
		BSIM3la0 = la0;
		BSIM3lags = lags;
		BSIM3la1 = la1;
		BSIM3la2 = la2;
		BSIM3lat = lat;
		BSIM3lketa = lketa;
		BSIM3lnsub = lnsub;
		BSIM3lnpeak = lnch;
		BSIM3lngate = lngate;
		BSIM3lgamma1 = lgamma1;
		BSIM3lgamma2 = lgamma2;
		BSIM3lvbx = lvbx;
		BSIM3lvbm = lvbm;
		BSIM3lxt = lxt;
		BSIM3lk1 = lk1;
		BSIM3lkt1 = lkt1;
		BSIM3lkt1l = lkt1l;
		BSIM3lkt2 = lkt2;
		BSIM3lk2 = lk2;
		BSIM3lk3 = lk3;
		BSIM3lk3b = lk3b;
		BSIM3lnlx = lnlx;
		BSIM3lw0 = lw0;
		BSIM3ldvt0 = ldvt0;
		BSIM3ldvt1 = ldvt1;
		BSIM3ldvt2 = ldvt2;
		BSIM3ldvt0w = ldvt0w;
		BSIM3ldvt1w = ldvt1w;
		BSIM3ldvt2w = ldvt2w;
		BSIM3ldrout = ldrout;
		BSIM3ldsub = ldsub;
		BSIM3lvth0 = lvth0;	//change from lvtho to lvth0
		BSIM3lua = lua;
		BSIM3lua1 = lua1;
		BSIM3lub = lub;
		BSIM3lub1 = lub1;
		BSIM3luc = luc;
		BSIM3luc1 = luc1;
		BSIM3lu0 = lu0;
		BSIM3lute = lute;
		BSIM3lvoff = lvoff;
		BSIM3ldelta = ldelta;
		BSIM3lrdsw = lrdsw;
		BSIM3lprwb = lprwb;
		BSIM3lprwg = lprwg;
		BSIM3lprt = lprt;
		BSIM3leta0 = leta0;
		BSIM3letab = letab;
		BSIM3lpclm = lpclm;
		BSIM3lpdibl1 = lpdiblc1;
		BSIM3lpdibl2 = lpdiblc2;
		BSIM3lpdiblb = lpdiblcb;
		BSIM3lpscbe1 = lpscbe1;
		BSIM3lpscbe2 = lpscbe2;
		BSIM3lpvag = lpvag;
		BSIM3lwr = lwr;
		BSIM3ldwg = ldwg;
		BSIM3ldwb = ldwb;
		BSIM3lb0 = lb0;
		BSIM3lb1 = lb1;
		BSIM3lalpha0 = lalpha0;
		BSIM3lalpha1 = lalpha1;
		BSIM3lbeta0 = lbeta0;
		BSIM3lvfb = lvfb;
		BSIM3lelm = lelm;
		BSIM3lcgsl = lcgsl;
		BSIM3lcgdl = lcgdl;
		BSIM3lckappa = lckappa;
		BSIM3lcf = lcf;
		BSIM3lclc = lclc;
		BSIM3lcle = lcle;
		BSIM3lvfbcv = lvfbcv;
		BSIM3lacde = lacde;
		BSIM3lmoin = lmoin;
		BSIM3lnoff = lnoff;
		BSIM3lvoffcv = lvoffcv;
		BSIM3wcdsc = wcdsc;
		BSIM3wcdscb = wcdscb;
		BSIM3wcdscd = wcdscd;
		BSIM3wcit = wcit;
		BSIM3wnfactor = wnfactor;
		BSIM3wxj = wxj;
		BSIM3wvsat = wvsat;
		BSIM3wa0 = wa0;
		BSIM3wags = wags;
		BSIM3wa1 = wa1;
		BSIM3wa2 = wa2;
		BSIM3wat = wat;
		BSIM3wketa = wketa;
		BSIM3wnsub = wnsub;
		BSIM3wnpeak = wnch;
		BSIM3wngate = wngate;
		BSIM3wgamma1 = wgamma1;
		BSIM3wgamma2 = wgamma2;
		BSIM3wvbx = wvbx;
		BSIM3wvbm = wvbm;
		BSIM3wxt = wxt;
		BSIM3wk1 = wk1;
		BSIM3wkt1 = wkt1;
		BSIM3wkt1l = wkt1l;
		BSIM3wkt2 = wkt2;
		BSIM3wk2 = wk2;
		BSIM3wk3 = wk3;
		BSIM3wk3b = wk3b;
		BSIM3wnlx = wnlx;
		BSIM3ww0 = ww0;
		BSIM3wdvt0 = wdvt0;
		BSIM3wdvt1 = wdvt1;
		BSIM3wdvt2 = wdvt2;
		BSIM3wdvt0w = wdvt0w;
		BSIM3wdvt1w = wdvt1w;
		BSIM3wdvt2w = wdvt2w;
		BSIM3wdrout = wdrout;
		BSIM3wdsub = wdsub;
		BSIM3wvth0 = wvth0;	//change from wvtho to wvth0
		BSIM3wua = wua;
		BSIM3wua1 = wua1;
		BSIM3wub = wub;
		BSIM3wub1 = wub1;
		BSIM3wuc = wuc;
		BSIM3wuc1 = wuc1;
		BSIM3wu0 = wu0;
		BSIM3wute = wute;
		BSIM3wvoff = wvoff;
		BSIM3wdelta = wdelta;
		BSIM3wrdsw = wrdsw;
		BSIM3wprwb = wprwb;
		BSIM3wprwg = wprwg;
		BSIM3wprt = wprt;
		BSIM3weta0 = weta0;
		BSIM3wetab = wetab;
		BSIM3wpclm = wpclm;
		BSIM3wpdibl1 = wpdiblc1;
		BSIM3wpdibl2 = wpdiblc2;
		BSIM3wpdiblb = wpdiblcb;
		BSIM3wpscbe1 = wpscbe1;
		BSIM3wpscbe2 = wpscbe2;
		BSIM3wpvag = wpvag;
		BSIM3wwr = wwr;
		BSIM3wdwg = wdwg;
		BSIM3wdwb = wdwb;
		BSIM3wb0 = wb0;
		BSIM3wb1 = wb1;
		BSIM3walpha0 = walpha0;
		BSIM3walpha1 = walpha1;
		BSIM3wbeta0 = wbeta0;
		BSIM3wvfb = wvfb;
		BSIM3welm = welm;
		BSIM3wcgsl = wcgsl;
		BSIM3wcgdl = wcgdl;
		BSIM3wckappa = wckappa;
		BSIM3wcf = wcf;
		BSIM3wclc = wclc;
		BSIM3wcle = wcle;
		BSIM3wvfbcv = wvfbcv;
		BSIM3wacde = wacde;
		BSIM3wmoin = wmoin;
		BSIM3wnoff = wnoff;
		BSIM3wvoffcv = wvoffcv;
		BSIM3pcdsc = pcdsc;
		BSIM3pcdscb = pcdscb;
		BSIM3pcdscd = pcdscd;
		BSIM3pcit = pcit;
		BSIM3pnfactor = pnfactor;
		BSIM3pxj = pxj;
		BSIM3pvsat = pvsat;
		BSIM3pa0 = pa0;
		BSIM3pags = pags;
		BSIM3pa1 = pa1;
		BSIM3pa2 = pa2;
		BSIM3pat = pat;
		BSIM3pketa = pketa;
		BSIM3pnsub = pnsub;
		BSIM3pnpeak = pnch;
		BSIM3pngate = pngate;
		BSIM3pgamma1 = pgamma1;
		BSIM3pgamma2 = pgamma2;
		BSIM3pvbx = pvbx;
		BSIM3pvbm = pvbm;
		BSIM3pxt = pxt;
		BSIM3pk1 = pk1;
		BSIM3pkt1 = pkt1;
		BSIM3pkt1l = pkt1l;
		BSIM3pkt2 = pkt2;
		BSIM3pk2 = pk2;
		BSIM3pk3 = pk3;
		BSIM3pk3b = pk3b;
		BSIM3pnlx = pnlx;
		BSIM3pw0 = pw0;
		BSIM3pdvt0 = pdvt0;
		BSIM3pdvt1 = pdvt1;
		BSIM3pdvt2 = pdvt2;
		BSIM3pdvt0w = pdvt0w;
		BSIM3pdvt1w = pdvt1w;
		BSIM3pdvt2w = pdvt2w;
		BSIM3pdrout = pdrout;
		BSIM3pdsub = pdsub;
		BSIM3pvth0 = pvth0;	//change from pvtho->pvth0
		BSIM3pua = pua;
		BSIM3pua1 = pua1;
		BSIM3pub = pub;
		BSIM3pub1 = pub1;
		BSIM3puc = puc;
		BSIM3puc1 = puc1;
		BSIM3pu0 = pu0;
		BSIM3pute = pute;
		BSIM3pvoff = pvoff;
		BSIM3pdelta = pdelta;
		BSIM3prdsw = prdsw;
		BSIM3pprwb = pprwb;
		BSIM3pprwg = pprwg;
		BSIM3pprt = pprt;
		BSIM3peta0 = peta0;
		BSIM3petab = petab;
		BSIM3ppclm = ppclm;
		BSIM3ppdibl1 = ppdiblc1;
		BSIM3ppdibl2 = ppdiblc2;
		BSIM3ppdiblb = ppdiblcb;
		BSIM3ppscbe1 = ppscbe1;
		BSIM3ppscbe2 = ppscbe2;
		BSIM3ppvag = ppvag;
		BSIM3pwr = pwr;
		BSIM3pdwg = pdwg;
		BSIM3pdwb = pdwb;
		BSIM3pb0 = pb0;
		BSIM3pb1 = pb1;
		BSIM3palpha0 = palpha0;
		BSIM3palpha1 = palpha1;
		BSIM3pbeta0 = pbeta0;
		BSIM3pvfb = pvfb;
		BSIM3pelm = pelm;
		BSIM3pcgsl = pcgsl;
		BSIM3pcgdl = pcgdl;
		BSIM3pckappa = pckappa;
		BSIM3pcf = pcf;
		BSIM3pclc = pclc;
		BSIM3pcle = pcle;
		BSIM3pvfbcv = pvfbcv;
		BSIM3pacde = pacde;
		BSIM3pmoin = pmoin;
		BSIM3pnoff = pnoff;
		BSIM3pvoffcv = pvoffcv;
		//BSIM3tnom = tnom;
		BSIM3tnom=tnom+273.15;
		BSIM3cgso = cgso;
		BSIM3cgdo = cgdo;
		BSIM3cgbo = cgbo;
		BSIM3xpart = xpart;
		BSIM3sheetResistance = rsh;
		BSIM3jctSatCurDensity = js;
		BSIM3jctSidewallSatCurDensity = jsw;
		BSIM3bulkJctPotential = pb;
		BSIM3bulkJctBotGradingCoeff = mj;
		BSIM3sidewallJctPotential = pbsw;
		BSIM3bulkJctSideGradingCoeff = mjsw;
		BSIM3unitAreaJctCap = cj;
		BSIM3unitLengthSidewallJctCap = cjsw;
		BSIM3jctEmissionCoeff = nj;
		BSIM3GatesidewallJctPotential = pbswg;
		BSIM3bulkJctGateSideGradingCoeff = mjswg;
		BSIM3unitLengthGateSidewallJctCap = cjswg;
		BSIM3jctTempExponent = xti;
		BSIM3Lint = lint;
		BSIM3Ll = ll;
		BSIM3Llc = llc;
		BSIM3Lln = lln;
		BSIM3Lw = lw;
		BSIM3Lwc = lwc;
		BSIM3Lwn = lwn;
		BSIM3Lwl = lwl;
		BSIM3Lwlc = lwlc;
		BSIM3Lmin = lmin;
		BSIM3Lmax = lmax;
		BSIM3Wint = wint;
		BSIM3Wl = wl;
		BSIM3Wlc = wlc;
		BSIM3Wln = wln;
		BSIM3Ww = ww;
		BSIM3Wwc = wwc;
		BSIM3Wwn = wwn;
		BSIM3Wwl = wwl;
		BSIM3Wwlc = wwlc;
		BSIM3Wmin = wmin;
		BSIM3Wmax = wmax;
		BSIM3oxideTrapDensityA = noia;
		BSIM3oxideTrapDensityB = noib;
		BSIM3oxideTrapDensityC = noic;
		BSIM3em = em;
		BSIM3ef = ef;
		BSIM3af = af;
		BSIM3kf = kf;

		BSIM3l=l;
		BSIM3w=w;

		//The following paragraph is adopted from b3set.c
		BSIM3type=Type;

		if (vth0 == `NOTGIVEN) 
			begin
			BSIM3vth0Given=0;
			BSIM3vth0 = (BSIM3type == 1) ? 0.7 : -0.7; // Default
			end
		else
			BSIM3vth0Given=1;
		
		if (k1==`NOTGIVEN) 
			begin
			BSIM3k1Given=0;
			BSIM3k1=0.53;//from b3temp.c
			end
		else
			BSIM3k1Given=1;

		if (k2==`NOTGIVEN) 
			begin
			BSIM3k2Given=0;
			BSIM3k2=-0.0186;//from b3temp.c
			end
		else
			BSIM3k2Given=1;

		if (ijth  == `NOTGIVEN)
			BSIM3ijth = 0.1;
		
		if (uc == `NOTGIVEN)
			BSIM3uc = (BSIM3mobMod == 3) ? -0.0465 : -0.0465e-9; // from b3set.c
	  
		if (uc1 == `NOTGIVEN)
			BSIM3uc1 = (BSIM3mobMod == 3) ? -0.056 : -0.056e-9; // from b3set.c
		
		if (u0 == `NOTGIVEN) 
			BSIM3u0 = (BSIM3type == 1 ) ? 0.067 : 0.025; // from b3set.c

		if (cf==`NOTGIVEN)
			BSIM3cf = 2.0 * `EPSOX / `PI * log(1.0 + 0.4e-6 / BSIM3tox);
			
		if (BSIM3dlc == `NOTGIVEN) 
			begin
			BSIM3dlcGiven=0;
			BSIM3dlc = BSIM3Lint;
			end
		else
			BSIM3dlcGiven=1;

		BSIM3cox= 3.453133e-11 / BSIM3tox;
		Cox = BSIM3cox;

		if (cgdo == `NOTGIVEN) 
			begin
			if (BSIM3dlc > 0.0)
				BSIM3cgdo = BSIM3dlc * BSIM3cox - BSIM3cgdl;
			else
				BSIM3cgdo = 0.6 * BSIM3xj * BSIM3cox;
			end
			
		if (BSIM3cgso == `NOTGIVEN) 
			begin
			if (BSIM3dlc > 0.0)
				BSIM3cgso = BSIM3dlc * BSIM3cox - BSIM3cgsl;
			else
				BSIM3cgso = 0.6 * BSIM3xj * BSIM3cox;
			end
		
		if (BSIM3cgbo == `NOTGIVEN)
			BSIM3cgbo = 2.0 * BSIM3dwc * BSIM3cox;

		//TODO/FIXME: add model parameter check (from b3check.c)
		//
		//
		/////////////////////////////////////////////////////////
		//
		// The following section is adopted from b3temp.c
		//
		/////////////////////////////////////////////////////////
		Tnom = BSIM3tnom;
		Temp = Tnom;
		TRatio = Temp / Tnom;
		 
		BSIM3vcrit = `CONSTvt0 * ln(`CONSTvt0 / (`CONSTroot * 1.0e-14));
		BSIM3factor1 = sqrt(`EPSSI / `EPSOX * BSIM3tox);

		Vtm0 = `KboQ * Tnom;
		Eg0 = 1.16 - 7.02e-4 * Tnom * Tnom / (Tnom + 1108.0);
		ni = 1.45e10 * (Tnom / 300.15) * sqrt(Tnom / 300.15) 
				* exp(21.5565981 - Eg0 / (2.0 * Vtm0));

		BSIM3vtm = `KboQ * Temp;
		Eg = 1.16 - 7.02e-4 * Temp * Temp / (Temp + 1108.0);
		if (Temp != Tnom)
		begin
			T0 = Eg0/Vtm0 -Eg/BSIM3vtm + BSIM3jctTempExponent* log(Temp / Tnom);
			T1 = exp(T0 / BSIM3jctEmissionCoeff);
			BSIM3jctTempSatCurDensity = BSIM3jctSatCurDensity * T1;
			BSIM3jctSidewallTempSatCurDensity = BSIM3jctSidewallSatCurDensity * T1;
		end
		else
		begin
			BSIM3jctTempSatCurDensity = BSIM3jctSatCurDensity;
			BSIM3jctSidewallTempSatCurDensity=BSIM3jctSidewallSatCurDensity;
		end

		if (BSIM3jctTempSatCurDensity < 0.0)
			BSIM3jctTempSatCurDensity = 0.0;
		if (BSIM3jctSidewallTempSatCurDensity < 0.0)
			BSIM3jctSidewallTempSatCurDensity = 0.0;

		 /* Temperature dependence of D/B and S/B diode capacitance begins */
		delTemp = `CKTtemp - BSIM3tnom;
		T0 = BSIM3tcj * delTemp;
		if (T0 >= -1.0)
			 BSIM3unitAreaTempJctCap = BSIM3unitAreaJctCap * (1.0 + T0);
		else if (BSIM3unitAreaJctCap > 0.0)
		begin
			 BSIM3unitAreaTempJctCap = 0.0;
			 $strobe("Temperature effect has caused cj to be negative. Cj is clamped to zero.\n");
		end
		 
		T0 = BSIM3tcjsw * delTemp;
		if (T0 >= -1.0)
			BSIM3unitLengthSidewallTempJctCap = BSIM3unitLengthSidewallJctCap * (1.0 + T0);
		else if (BSIM3unitLengthSidewallJctCap > 0.0)
		begin
			BSIM3unitLengthSidewallTempJctCap = 0.0;
			$strobe("Temperature effect has caused cjsw to be negative. Cjsw is clamped to zero.\n");
		end
		
		T0 = BSIM3tcjswg * delTemp;
		if (T0 >= -1.0)
			BSIM3unitLengthGateSidewallTempJctCap=BSIM3unitLengthGateSidewallJctCap*(1.0+T0);
		else if (BSIM3unitLengthGateSidewallJctCap > 0.0)
		begin
			BSIM3unitLengthGateSidewallTempJctCap = 0.0;
			$strobe("Temperature effect has caused cjswg to be negative. Cjswg is clamped to zero.\n");
		end

		BSIM3PhiB = BSIM3bulkJctPotential - BSIM3tpb * delTemp;
		if (BSIM3PhiB < 0.01)
		begin
			BSIM3PhiB = 0.01;
			$strobe("Temperature effect has caused pb to be less than 0.01. Pb is clamped to 0.01.\n");
		end
		
		BSIM3PhiBSW = BSIM3sidewallJctPotential - BSIM3tpbsw * delTemp;
		if (BSIM3PhiBSW <= 0.01)
		begin
			BSIM3PhiBSW = 0.01;
			$strobe("Temperature effect has caused pbsw to be less than 0.01. Pbsw is clamped to 0.01.\n");
		end

		BSIM3PhiBSWG = BSIM3GatesidewallJctPotential- BSIM3tpbswg * delTemp;
		if (BSIM3PhiBSWG <= 0.01)
		begin
			BSIM3PhiBSWG = 0.01;
			$strobe("Temperature effect has caused pbswg to be less than 0.01. Pbswg is clamped to 0.01.\n");
		end
		/* End of junction capacitance */
		
		Ldrn = l;
		Wdrn = w;
		Length = Ldrn;
		Width = Wdrn;
			  
		T0 = pow(Ldrn, BSIM3Lln);
		T1 = pow(Wdrn, BSIM3Lwn);
		tmp1=BSIM3Ll/T0+BSIM3Lw/T1+BSIM3Lwl/(T0*T1);
		BSIM3dl = BSIM3Lint + tmp1;
		tmp2 = BSIM3Llc / T0 + BSIM3Lwc / T1+ BSIM3Lwlc / (T0 * T1);
		BSIM3dlc = BSIM3dlc + tmp2;
		T2 = pow(Ldrn, BSIM3Wln);
		T3 = pow(Wdrn, BSIM3Wwn);
		tmp1 = BSIM3Wl / T2 + BSIM3Ww / T3 + BSIM3Wwl / (T2 * T3);
		BSIM3dw = BSIM3Wint + tmp1;
		tmp2 = BSIM3Wlc / T2 + BSIM3Wwc / T3+ BSIM3Wwlc / (T2 * T3);
		BSIM3dwc = BSIM3dwc + tmp2;

		BSIM3leff = BSIM3l - 2.0 *BSIM3dl;

		if (BSIM3leff <= 0.0)
		begin
			$strobe("BSIM3: Effective channel length <= 0\n");
			$finish(-1);
		end

		BSIM3weff = BSIM3w - 2.0 * BSIM3dw;
		if (BSIM3weff <= 0.0)
		begin
			$strobe("BSIM3: Effective channel width <= 0\n");
			$finish(-1);
		end

		BSIM3leffCV = BSIM3l - 2.0 * BSIM3dlc;
		if (BSIM3leffCV <= 0.0)
		begin
			$strobe("BSIM3: Effective channel length for C-V <= 0\n");
			$finish(-1);
		end

		BSIM3weffCV = BSIM3w - 2.0 * BSIM3dwc;
		if (BSIM3weffCV <= 0.0)
		begin
			$strobe("BSIM3: Effective channel width for C-V <= 0\n");
			$finish(-1);
		end

		if (BSIM3binUnit == 1)
		begin
			Inv_L = 1.0e-6 / BSIM3leff;
			Inv_W = 1.0e-6 / BSIM3weff;
			Inv_LW = 1.0e-12 / (BSIM3leff * BSIM3weff);
		end
		else
		begin
			Inv_L = 1.0 / BSIM3leff;
			Inv_W = 1.0 / BSIM3weff;
			Inv_LW = 1.0 / (BSIM3leff*BSIM3weff);
		end

		BSIM3cdsc = BSIM3cdsc
				+ BSIM3lcdsc * Inv_L
				+ BSIM3wcdsc * Inv_W
				+ BSIM3pcdsc * Inv_LW;
		BSIM3cdscb = BSIM3cdscb
				 + BSIM3lcdscb * Inv_L
				 + BSIM3wcdscb * Inv_W
				 + BSIM3pcdscb * Inv_LW; 
				 
		BSIM3cdscd = BSIM3cdscd
				 + BSIM3lcdscd * Inv_L
				 + BSIM3wcdscd * Inv_W
				 + BSIM3pcdscd * Inv_LW; 
				 
		BSIM3cit = BSIM3cit
			   + BSIM3lcit * Inv_L
			   + BSIM3wcit * Inv_W
			   + BSIM3pcit * Inv_LW;
		BSIM3nfactor = BSIM3nfactor
				   + BSIM3lnfactor * Inv_L
				   + BSIM3wnfactor * Inv_W
				   + BSIM3pnfactor * Inv_LW;
		BSIM3xj = BSIM3xj
			  + BSIM3lxj * Inv_L
			  + BSIM3wxj * Inv_W
			  + BSIM3pxj * Inv_LW;
		BSIM3vsat = BSIM3vsat
				+ BSIM3lvsat * Inv_L
				+ BSIM3wvsat * Inv_W
				+ BSIM3pvsat * Inv_LW;
		BSIM3at = BSIM3at
			  + BSIM3lat * Inv_L
			  + BSIM3wat * Inv_W
			  + BSIM3pat * Inv_LW;
		BSIM3a0 = BSIM3a0
			  + BSIM3la0 * Inv_L
			  + BSIM3wa0 * Inv_W
			  + BSIM3pa0 * Inv_LW; 
			  
		BSIM3ags = BSIM3ags
			  + BSIM3lags * Inv_L
			  + BSIM3wags * Inv_W
			  + BSIM3pags * Inv_LW;
			  
		BSIM3a1 = BSIM3a1
			  + BSIM3la1 * Inv_L
			  + BSIM3wa1 * Inv_W
			  + BSIM3pa1 * Inv_LW;
		BSIM3a2 = BSIM3a2
			  + BSIM3la2 * Inv_L
			  + BSIM3wa2 * Inv_W
			  + BSIM3pa2 * Inv_LW;
		BSIM3keta = BSIM3keta
				+ BSIM3lketa * Inv_L
				+ BSIM3wketa * Inv_W
				+ BSIM3pketa * Inv_LW;
		BSIM3nsub = BSIM3nsub
				+ BSIM3lnsub * Inv_L
				+ BSIM3wnsub * Inv_W
				+ BSIM3pnsub * Inv_LW;
		BSIM3npeak = BSIM3npeak
				 + BSIM3lnpeak * Inv_L
				 + BSIM3wnpeak * Inv_W
				 + BSIM3pnpeak * Inv_LW;
		BSIM3ngate = BSIM3ngate
				 + BSIM3lngate * Inv_L
				 + BSIM3wngate * Inv_W
				 + BSIM3pngate * Inv_LW;
		BSIM3gamma1 = BSIM3gamma1
				  + BSIM3lgamma1 * Inv_L
				  + BSIM3wgamma1 * Inv_W
				  + BSIM3pgamma1 * Inv_LW;
		BSIM3gamma2 = BSIM3gamma2
				  + BSIM3lgamma2 * Inv_L
				  + BSIM3wgamma2 * Inv_W
				  + BSIM3pgamma2 * Inv_LW;
		BSIM3vbx = BSIM3vbx
			   + BSIM3lvbx * Inv_L
			   + BSIM3wvbx * Inv_W
			   + BSIM3pvbx * Inv_LW;
		BSIM3vbm = BSIM3vbm
			   + BSIM3lvbm * Inv_L
			   + BSIM3wvbm * Inv_W
			   + BSIM3pvbm * Inv_LW;
		BSIM3xt = BSIM3xt
			   + BSIM3lxt * Inv_L
			   + BSIM3wxt * Inv_W
			   + BSIM3pxt * Inv_LW;
		BSIM3vfb = BSIM3vfb
			   + BSIM3lvfb * Inv_L
			   + BSIM3wvfb * Inv_W
			   + BSIM3pvfb * Inv_LW;
		BSIM3k1 = BSIM3k1
		  + BSIM3lk1 * Inv_L
		  + BSIM3wk1 * Inv_W
		  + BSIM3pk1 * Inv_LW;
		BSIM3kt1 = BSIM3kt1
		   + BSIM3lkt1 * Inv_L
		   + BSIM3wkt1 * Inv_W
		   + BSIM3pkt1 * Inv_LW;
		BSIM3kt1l = BSIM3kt1l
			+ BSIM3lkt1l * Inv_L
			+ BSIM3wkt1l * Inv_W
			+ BSIM3pkt1l * Inv_LW;
		BSIM3k2 = BSIM3k2
		  + BSIM3lk2 * Inv_L
		  + BSIM3wk2 * Inv_W
		  + BSIM3pk2 * Inv_LW;
		BSIM3kt2 = BSIM3kt2
		   + BSIM3lkt2 * Inv_L
		   + BSIM3wkt2 * Inv_W
		   + BSIM3pkt2 * Inv_LW;
		BSIM3k3 = BSIM3k3
		  + BSIM3lk3 * Inv_L
		  + BSIM3wk3 * Inv_W
		  + BSIM3pk3 * Inv_LW;
		BSIM3k3b = BSIM3k3b
			   + BSIM3lk3b * Inv_L
			   + BSIM3wk3b * Inv_W
			   + BSIM3pk3b * Inv_LW;
		BSIM3w0 = BSIM3w0
			  + BSIM3lw0 * Inv_L
			  + BSIM3ww0 * Inv_W
			  + BSIM3pw0 * Inv_LW;
		BSIM3nlx = BSIM3nlx
			   + BSIM3lnlx * Inv_L
			   + BSIM3wnlx * Inv_W
			   + BSIM3pnlx * Inv_LW;
		BSIM3dvt0 = BSIM3dvt0
				+ BSIM3ldvt0 * Inv_L
				+ BSIM3wdvt0 * Inv_W
				+ BSIM3pdvt0 * Inv_LW;
		BSIM3dvt1 = BSIM3dvt1
				+ BSIM3ldvt1 * Inv_L
				+ BSIM3wdvt1 * Inv_W
				+ BSIM3pdvt1 * Inv_LW;
		BSIM3dvt2 = BSIM3dvt2
				+ BSIM3ldvt2 * Inv_L
				+ BSIM3wdvt2 * Inv_W
				+ BSIM3pdvt2 * Inv_LW;
		BSIM3dvt0w = BSIM3dvt0w
				+ BSIM3ldvt0w * Inv_L
				+ BSIM3wdvt0w * Inv_W
				+ BSIM3pdvt0w * Inv_LW;
		BSIM3dvt1w = BSIM3dvt1w
				+ BSIM3ldvt1w * Inv_L
				+ BSIM3wdvt1w * Inv_W
				+ BSIM3pdvt1w * Inv_LW;
		BSIM3dvt2w = BSIM3dvt2w
				+ BSIM3ldvt2w * Inv_L
				+ BSIM3wdvt2w * Inv_W
				+ BSIM3pdvt2w * Inv_LW;
		BSIM3drout = BSIM3drout
				 + BSIM3ldrout * Inv_L
				 + BSIM3wdrout * Inv_W
				 + BSIM3pdrout * Inv_LW;
		BSIM3dsub = BSIM3dsub
				+ BSIM3ldsub * Inv_L
				+ BSIM3wdsub * Inv_W
				+ BSIM3pdsub * Inv_LW;
		BSIM3vth0 = BSIM3vth0
				+ BSIM3lvth0 * Inv_L
				+ BSIM3wvth0 * Inv_W
				+ BSIM3pvth0 * Inv_LW;
		BSIM3ua = BSIM3ua
			  + BSIM3lua * Inv_L
			  + BSIM3wua * Inv_W
			  + BSIM3pua * Inv_LW;
		BSIM3ua1 = BSIM3ua1
			   + BSIM3lua1 * Inv_L
			   + BSIM3wua1 * Inv_W
			   + BSIM3pua1 * Inv_LW;
		BSIM3ub = BSIM3ub
			  + BSIM3lub * Inv_L
			  + BSIM3wub * Inv_W
			  + BSIM3pub * Inv_LW;
		BSIM3ub1 = BSIM3ub1
			   + BSIM3lub1 * Inv_L
			   + BSIM3wub1 * Inv_W
			   + BSIM3pub1 * Inv_LW;
		BSIM3uc = BSIM3uc
			  + BSIM3luc * Inv_L
			  + BSIM3wuc * Inv_W
			  + BSIM3puc * Inv_LW;
		BSIM3uc1 = BSIM3uc1
			   + BSIM3luc1 * Inv_L
			   + BSIM3wuc1 * Inv_W
			   + BSIM3puc1 * Inv_LW;
		BSIM3u0 = BSIM3u0
			  + BSIM3lu0 * Inv_L
			  + BSIM3wu0 * Inv_W
			  + BSIM3pu0 * Inv_LW;
		BSIM3ute = BSIM3ute
			   + BSIM3lute * Inv_L
			   + BSIM3wute * Inv_W
			   + BSIM3pute * Inv_LW;
		BSIM3voff = BSIM3voff
				+ BSIM3lvoff * Inv_L
				+ BSIM3wvoff * Inv_W
				+ BSIM3pvoff * Inv_LW;
		BSIM3delta = BSIM3delta
				 + BSIM3ldelta * Inv_L
				 + BSIM3wdelta * Inv_W
				 + BSIM3pdelta * Inv_LW;
		BSIM3rdsw = BSIM3rdsw
				+ BSIM3lrdsw * Inv_L
				+ BSIM3wrdsw * Inv_W
				+ BSIM3prdsw * Inv_LW;
		BSIM3prwg = BSIM3prwg
				+ BSIM3lprwg * Inv_L
				+ BSIM3wprwg * Inv_W
				+ BSIM3pprwg * Inv_LW;
		BSIM3prwb = BSIM3prwb
				+ BSIM3lprwb * Inv_L
				+ BSIM3wprwb * Inv_W
				+ BSIM3pprwb * Inv_LW;
		BSIM3prt = BSIM3prt
				+ BSIM3lprt * Inv_L
				+ BSIM3wprt * Inv_W
				+ BSIM3pprt * Inv_LW;
		BSIM3eta0 = BSIM3eta0
				+ BSIM3leta0 * Inv_L
				+ BSIM3weta0 * Inv_W
				+ BSIM3peta0 * Inv_LW;
		BSIM3etab = BSIM3etab
				+ BSIM3letab * Inv_L
				+ BSIM3wetab * Inv_W
				+ BSIM3petab * Inv_LW;
		BSIM3pclm = BSIM3pclm
				+ BSIM3lpclm * Inv_L
				+ BSIM3wpclm * Inv_W
				+ BSIM3ppclm * Inv_LW;
		BSIM3pdibl1 = BSIM3pdibl1
				  + BSIM3lpdibl1 * Inv_L
				  + BSIM3wpdibl1 * Inv_W
				  + BSIM3ppdibl1 * Inv_LW;
		BSIM3pdibl2 = BSIM3pdibl2
				  + BSIM3lpdibl2 * Inv_L
				  + BSIM3wpdibl2 * Inv_W
				  + BSIM3ppdibl2 * Inv_LW;
		BSIM3pdiblb = BSIM3pdiblb
				  + BSIM3lpdiblb * Inv_L
				  + BSIM3wpdiblb * Inv_W
				  + BSIM3ppdiblb * Inv_LW;
		BSIM3pscbe1 = BSIM3pscbe1
				  + BSIM3lpscbe1 * Inv_L
				  + BSIM3wpscbe1 * Inv_W
				  + BSIM3ppscbe1 * Inv_LW;
		BSIM3pscbe2 = BSIM3pscbe2
				  + BSIM3lpscbe2 * Inv_L
				  + BSIM3wpscbe2 * Inv_W
				  + BSIM3ppscbe2 * Inv_LW;
		BSIM3pvag = BSIM3pvag
				+ BSIM3lpvag * Inv_L
				+ BSIM3wpvag * Inv_W
				+ BSIM3ppvag * Inv_LW;
		BSIM3wr = BSIM3wr
			  + BSIM3lwr * Inv_L
			  + BSIM3wwr * Inv_W
			  + BSIM3pwr * Inv_LW;
		BSIM3dwg = BSIM3dwg
			   + BSIM3ldwg * Inv_L
			   + BSIM3wdwg * Inv_W
			   + BSIM3pdwg * Inv_LW;
		BSIM3dwb = BSIM3dwb
			   + BSIM3ldwb * Inv_L
			   + BSIM3wdwb * Inv_W
			   + BSIM3pdwb * Inv_LW;
		BSIM3b0 = BSIM3b0
			  + BSIM3lb0 * Inv_L
			  + BSIM3wb0 * Inv_W
			  + BSIM3pb0 * Inv_LW;
		BSIM3b1 = BSIM3b1
			  + BSIM3lb1 * Inv_L
			  + BSIM3wb1 * Inv_W
			  + BSIM3pb1 * Inv_LW;
		BSIM3alpha0 = BSIM3alpha0
				  + BSIM3lalpha0 * Inv_L
				  + BSIM3walpha0 * Inv_W
				  + BSIM3palpha0 * Inv_LW;
		BSIM3alpha1 = BSIM3alpha1
							  + BSIM3lalpha1 * Inv_L
							  + BSIM3walpha1 * Inv_W
							  + BSIM3palpha1 * Inv_LW;
		BSIM3beta0 = BSIM3beta0
				 + BSIM3lbeta0 * Inv_L
				 + BSIM3wbeta0 * Inv_W
				 + BSIM3pbeta0 * Inv_LW;
		/* CV model */
		BSIM3elm = BSIM3elm
			  + BSIM3lelm * Inv_L
			  + BSIM3welm * Inv_W
			  + BSIM3pelm * Inv_LW;
		BSIM3cgsl = BSIM3cgsl
				+ BSIM3lcgsl * Inv_L
				+ BSIM3wcgsl * Inv_W
				+ BSIM3pcgsl * Inv_LW;
		BSIM3cgdl = BSIM3cgdl
				+ BSIM3lcgdl * Inv_L
				+ BSIM3wcgdl * Inv_W
				+ BSIM3pcgdl * Inv_LW;
		BSIM3ckappa = BSIM3ckappa
				  + BSIM3lckappa * Inv_L
				  + BSIM3wckappa * Inv_W
				  + BSIM3pckappa * Inv_LW;
		BSIM3cf = BSIM3cf
			  + BSIM3lcf * Inv_L
			  + BSIM3wcf * Inv_W
			  + BSIM3pcf * Inv_LW;
		BSIM3clc = BSIM3clc
			   + BSIM3lclc * Inv_L
			   + BSIM3wclc * Inv_W
			   + BSIM3pclc * Inv_LW;
		BSIM3cle = BSIM3cle
			   + BSIM3lcle * Inv_L
			   + BSIM3wcle * Inv_W
			   + BSIM3pcle * Inv_LW;
		BSIM3vfbcv = BSIM3vfbcv
				 + BSIM3lvfbcv * Inv_L
				 + BSIM3wvfbcv * Inv_W
				 + BSIM3pvfbcv * Inv_LW;
		BSIM3acde = BSIM3acde
						+ BSIM3lacde * Inv_L
						+ BSIM3wacde * Inv_W
						+ BSIM3pacde * Inv_LW;
		BSIM3moin = BSIM3moin
						+ BSIM3lmoin * Inv_L
						+ BSIM3wmoin * Inv_W
						+ BSIM3pmoin * Inv_LW;
		BSIM3noff = BSIM3noff
						+ BSIM3lnoff * Inv_L
						+ BSIM3wnoff * Inv_W
						+ BSIM3pnoff * Inv_LW;
		BSIM3voffcv = BSIM3voffcv
						  + BSIM3lvoffcv * Inv_L
						  + BSIM3wvoffcv * Inv_W
						  + BSIM3pvoffcv * Inv_LW;

		BSIM3abulkCVfactor = 1.0 + pow((BSIM3clc
				 / BSIM3leffCV), BSIM3cle);

		T0 = (TRatio - 1.0);
		BSIM3ua = BSIM3ua + BSIM3ua1 * T0;
		BSIM3ub = BSIM3ub + BSIM3ub1 * T0;
		BSIM3uc = BSIM3uc + BSIM3uc1 * T0;
		
		if (BSIM3u0 > 1.0) 
			BSIM3u0 = BSIM3u0 / 1.0e4;
		BSIM3u0temp = BSIM3u0* pow(TRatio, BSIM3ute); 

		BSIM3vsattemp = BSIM3vsat - BSIM3at * T0;
		BSIM3rds0 = (BSIM3rdsw + BSIM3prt * T0)/ pow(BSIM3weff * 1E6, BSIM3wr);

		//TODO/FIXME: check parameters
		/*
		if (BSIM3checkModel(model, here, ckt))
		{   IFuid namarray[2];
			namarray[0] = model->BSIM3modName;
			namarray[1] = here->BSIM3name;
		   (*(SPfrontEnd->IFerror)) (ERR_FATAL, "Fatal error(s) detected during BSIM3V3.2 parameter checking for %s in model %s", namarray);
			return(E_BADPARM);   
			}
		*/
		BSIM3cgdo = (BSIM3cgdo + BSIM3cf) * BSIM3weffCV;
		BSIM3cgso = (BSIM3cgso + BSIM3cf) * BSIM3weffCV;
		BSIM3cgbo = BSIM3cgbo * BSIM3leffCV;
		T0 = BSIM3leffCV * BSIM3leffCV;
		BSIM3tconst = BSIM3u0temp * BSIM3elm / (BSIM3cox* BSIM3weffCV * BSIM3leffCV * T0);
		if (BSIM3npeak==`NOTGIVEN && BSIM3gamma1!=`NOTGIVEN)
		begin
			T0 = BSIM3gamma1 * BSIM3cox;
			BSIM3npeak = 3.021E22 * T0 * T0;
		end

		BSIM3phi = 2.0 * Vtm0 * log(BSIM3npeak / ni);
		BSIM3sqrtPhi = sqrt(BSIM3phi);
		BSIM3phis3 = BSIM3sqrtPhi * BSIM3phi;
		BSIM3Xdep0 = sqrt(2.0 * `EPSSI / (`Charge_q * BSIM3npeak * 1.0e6))* BSIM3sqrtPhi; 
		BSIM3sqrtXdep0 = sqrt(BSIM3Xdep0);
		BSIM3litl = sqrt(3.0 * BSIM3xj * BSIM3tox);
		BSIM3vbi = Vtm0 * log(1.0e20 * BSIM3npeak / (ni * ni));
		BSIM3cdep0 = sqrt(`Charge_q * `EPSSI * BSIM3npeak * 1.0e6 / 2.0/ BSIM3phi);
		BSIM3ldeb = sqrt(`EPSSI * Vtm0 / (`Charge_q* BSIM3npeak * 1.0e6)) / 3.0;
		BSIM3acde = BSIM3acde*pow((BSIM3npeak / 2.0e16), -0.25);

		if (BSIM3k1Given || BSIM3k2Given) 
		begin
			if (!BSIM3k1Given)
			begin
				$strobe("Warning: k1 should be specified with k2.\n");
				BSIM3k1 = 0.53;
			end
			if (!BSIM3k2Given)
			begin
				$strobe("Warning: k2 should be specified with k1.\n");
				BSIM3k2 = -0.0186;
			end
			if (BSIM3nsubGiven)
				$strobe("Warning: nsub is ignored because k1 or k2 is given.\n");
			if (BSIM3xtGiven)
				$strobe("Warning: xt is ignored because k1 or k2 is given.\n");
			if (BSIM3vbxGiven)
				$strobe("Warning: vbx is ignored because k1 or k2 is given.\n");
			if (BSIM3gamma1Given)
				$strobe("Warning: gamma1 is ignored because k1 or k2 is given.\n");
			if (BSIM3gamma2Given)
				$strobe("Warning: gamma2 is ignored because k1 or k2 is given.\n");
		end
		else
		begin
			if (!BSIM3vbxGiven)
				BSIM3vbx = BSIM3phi - 7.7348e-4 * BSIM3npeak * BSIM3xt * BSIM3xt;
			if (BSIM3vbx > 0.0)
				BSIM3vbx = -BSIM3vbx;
			if (BSIM3vbm > 0.0)
				BSIM3vbm = -BSIM3vbm;
			if (BSIM3gamma1==`NOTGIVEN)
				BSIM3gamma1 = 5.753e-12* sqrt(BSIM3npeak) / BSIM3cox;
			if (BSIM3gamma2==`NOTGIVEN)
				BSIM3gamma2 = 5.753e-12 * sqrt(BSIM3nsub)/ BSIM3cox;
			T0 = BSIM3gamma1 - BSIM3gamma2;
			T1 = sqrt(BSIM3phi - BSIM3vbx) - BSIM3sqrtPhi;
			T2 = sqrt(BSIM3phi * (BSIM3phi - BSIM3vbm)) - BSIM3phi;
			BSIM3k2 = T0 * T1 / (2.0 * T2 + BSIM3vbm);
			BSIM3k1 = BSIM3gamma2 - 2.0* BSIM3k2 * sqrt(BSIM3phi- BSIM3vbm);
		end
		
		if (BSIM3k2 < 0.0)
		begin
			T0 = 0.5 * BSIM3k1 / BSIM3k2;
			BSIM3vbsc = 0.9 * (BSIM3phi - T0 * T0);
			if (BSIM3vbsc > -3.0)
				BSIM3vbsc = -3.0;
			else if (BSIM3vbsc < -30.0)
				BSIM3vbsc = -30.0;
		end
		else
			BSIM3vbsc = -30.0;
		
		if (BSIM3vbsc > BSIM3vbm)
			BSIM3vbsc = BSIM3vbm;
		if (!BSIM3vfbGiven)
		begin
			if (BSIM3vth0Given)
				BSIM3vfb = BSIM3type * BSIM3vth0 - BSIM3phi - BSIM3k1* BSIM3sqrtPhi;
			else
				BSIM3vfb = -1.0;
		end

		if (!BSIM3vth0Given)
			BSIM3vth0 = BSIM3type * (BSIM3vfb+ BSIM3phi + BSIM3k1* BSIM3sqrtPhi);
		
		BSIM3k1ox = BSIM3k1 * BSIM3tox/ BSIM3toxm;
		BSIM3k2ox = BSIM3k2 * BSIM3tox/ BSIM3toxm;
		T1 = sqrt(`EPSSI / `EPSOX * BSIM3tox * BSIM3Xdep0);

		T0 = exp(-0.5 * BSIM3dsub * BSIM3leff / T1);
		BSIM3theta0vb0 = (T0 + 2.0 * T0 * T0);

		T0 = exp(-0.5 * BSIM3drout * BSIM3leff / T1);
		T2 = (T0 + 2.0 * T0 * T0);
		BSIM3thetaRout = BSIM3pdibl1 * T2 + BSIM3pdibl2;

		tmp = sqrt(BSIM3Xdep0);
		tmp1 = BSIM3vbi - BSIM3phi;
		tmp2 = BSIM3factor1 * tmp;

		T0 = -0.5 * BSIM3dvt1w * BSIM3weff * BSIM3leff / tmp2;
		if (T0 > -`EXP_THRESHOLD)
		begin
			T1 = exp(T0);
			T2 = T1 * (1.0 + 2.0 * T1);
		end
		else
		begin  
			T1 = `MIN_EXP;
			T2 = T1 * (1.0 + 2.0 * T1);
		end
		T0 = BSIM3dvt0w * T2;
		T2 = T0 * tmp1;

		T0 = -0.5 * BSIM3dvt1 * BSIM3leff / tmp2;
		if (T0 > -`EXP_THRESHOLD)
		begin   
			T1 = exp(T0);
			T3 = T1 * (1.0 + 2.0 * T1);
		end
		else
		begin   
			T1 = `MIN_EXP;
			T3 = T1 * (1.0 + 2.0 * T1);
		end
		T3 = BSIM3dvt0 * T3 * tmp1;

		T4 = BSIM3tox * BSIM3phi/ (BSIM3weff + BSIM3w0);

		T0 = sqrt(1.0 + BSIM3nlx / BSIM3leff);
		T5 = BSIM3k1ox * (T0 - 1.0) * BSIM3sqrtPhi + (BSIM3kt1 + BSIM3kt1l / BSIM3leff)
			* (TRatio - 1.0);

		tmp3 = BSIM3type * BSIM3vth0 - T2 - T3 + BSIM3k3 * T4 + T5;
		BSIM3vfbzb = tmp3 - BSIM3phi - BSIM3k1 * BSIM3sqrtPhi;
		/* End of vfbzb */
		
		/* process source/drain series resistance */
		BSIM3drainConductance = BSIM3sheetResistance * BSIM3drainSquares;
		if (BSIM3drainConductance > 0.0)
			BSIM3drainConductance = 1.0 / BSIM3drainConductance;
		else
			BSIM3drainConductance = 0.0;

		BSIM3sourceConductance = BSIM3sheetResistance * BSIM3sourceSquares;
		if (BSIM3sourceConductance > 0.0) 
			BSIM3sourceConductance = 1.0 / BSIM3sourceConductance;
		else
			BSIM3sourceConductance = 0.0;
		//BSIM3cgso = BSIM3cgso;
		//BSIM3cgdo = BSIM3cgdo;

		Nvtm = BSIM3vtm * BSIM3jctEmissionCoeff;
		if ((BSIM3sourceArea <= 0.0) && (BSIM3sourcePerimeter <= 0.0))
			SourceSatCurrent = 1.0e-14;
		else
			SourceSatCurrent = BSIM3sourceArea* BSIM3jctTempSatCurDensity
								+ BSIM3sourcePerimeter* BSIM3jctSidewallTempSatCurDensity;
		if ((SourceSatCurrent > 0.0) && (BSIM3ijth > 0.0))
		begin
			BSIM3vjsm = Nvtm * log(BSIM3ijth/ SourceSatCurrent + 1.0);
			BSIM3IsEvjsm = SourceSatCurrent * exp(BSIM3vjsm/ Nvtm);
		end
		if ((BSIM3drainArea <= 0.0) && (BSIM3drainPerimeter <= 0.0))
			DrainSatCurrent = 1.0e-14;
		else
			DrainSatCurrent = BSIM3drainArea * BSIM3jctTempSatCurDensity
							+ BSIM3drainPerimeter* BSIM3jctSidewallTempSatCurDensity;
				  if ((DrainSatCurrent > 0.0) && (BSIM3ijth > 0.0))
		begin
			BSIM3vjdm = Nvtm * log(BSIM3ijth/ DrainSatCurrent + 1.0);
			BSIM3IsEvjdm = DrainSatCurrent * exp(BSIM3vjdm/ Nvtm);
		end

		////////////////////////////////////////////////////
		//
		// BSIM3 DC calculation begins (section 2)
		//
		///////////////////////////////////////////////////
		
		/* determine DC current and derivatives */
		vds=BSIM3type*V(vdp,vsp);
		vbs=BSIM3type*V(vb, vsp);
		vgs=BSIM3type*V(vg, vsp);

		vbd = vbs - vds;
		vgd = vgs - vds;
		vgb = vgs - vbs;

		/* Source/drain junction diode DC model begins */
		Nvtm = BSIM3vtm * BSIM3jctEmissionCoeff;
		if ((BSIM3sourceArea <= 0.0) && (BSIM3sourcePerimeter <= 0.0))
			SourceSatCurrent = 1.0e-14;
		else
			SourceSatCurrent = BSIM3sourceArea*BSIM3jctTempSatCurDensity
							+BSIM3sourcePerimeter*BSIM3jctSidewallTempSatCurDensity;

		if (SourceSatCurrent <= 0.0) 
			BSIM3cbs =`CKTgmin * vbs;
		else 
			begin
			if (BSIM3ijth == 0.0) 
				begin
				evbs = exp(vbs / Nvtm);
				BSIM3cbs = SourceSatCurrent * (evbs - 1.0) + `CKTgmin * vbs; 
				end
			else 
				begin
				if (vbs < BSIM3vjsm) 
					begin
					evbs = exp(vbs / Nvtm);
					BSIM3cbs = SourceSatCurrent * (evbs - 1.0) + `CKTgmin * vbs;
					end
				else 
					begin
					T0 = BSIM3IsEvjsm / Nvtm;
					BSIM3cbs=BSIM3IsEvjsm-SourceSatCurrent+T0*(vbs-BSIM3vjsm)+`CKTgmin*vbs;
					end
				end
			end

		if ((BSIM3drainArea <= 0.0) && (BSIM3drainPerimeter <= 0.0))
			DrainSatCurrent = 1.0e-14;
		else 
			DrainSatCurrent = BSIM3drainArea 
						* BSIM3jctTempSatCurDensity
						+ BSIM3drainPerimeter
						* BSIM3jctSidewallTempSatCurDensity;

		if (DrainSatCurrent <= 0.0) 
			begin
			BSIM3gbd = `CKTgmin;
			BSIM3cbd = BSIM3gbd * vbd;
			end
		else 
			begin
			if (BSIM3ijth == 0.0) 
				begin
				evbd = exp(vbd / Nvtm);
				BSIM3cbd = DrainSatCurrent * (evbd - 1.0) + `CKTgmin * vbd;
				end
			else 
				begin
				if (vbd < BSIM3vjdm) 
					begin
					evbd = exp(vbd / Nvtm);
					BSIM3cbd = DrainSatCurrent * (evbd - 1.0) + `CKTgmin * vbd;
					end
				else 
					begin
					T0 = BSIM3IsEvjdm / Nvtm;
					BSIM3cbd = BSIM3IsEvjdm - DrainSatCurrent + T0 * (vbd - BSIM3vjdm)
										 + `CKTgmin * vbd;
					end
				end
			end

		/* End of diode DC model */

		if (vds >= 0.0)
			begin
			/* normal mode */
			BSIM3mode = 1;
			Vds = vds;
			Vgs = vgs;
			Vbs = vbs;
			end
		else
			begin
			/* inverse mode */
			BSIM3mode = -1;
			Vds = -vds;
			Vgs = vgd;
			Vbs = vbd;
			end

		T0 = Vbs - BSIM3vbsc - 0.001;
		T1 = sqrt(T0 * T0 - 0.004 * BSIM3vbsc);
		Vbseff = BSIM3vbsc + 0.5 * (T0 + T1);
		if (Vbseff < Vbs)
			Vbseff = Vbs;
		
		if (Vbseff > 0.0)
			begin   
			T0 = BSIM3phi / (BSIM3phi + Vbseff);
			Phis = BSIM3phi * T0;
			sqrtPhis = BSIM3phis3 / (BSIM3phi + 0.5 * Vbseff);
			end
		else
			begin  
			Phis = BSIM3phi - Vbseff;
			sqrtPhis = sqrt(Phis);
			end

		Xdep = BSIM3Xdep0 * sqrtPhis / BSIM3sqrtPhi;

		Leff = BSIM3leff;
		Vtm = BSIM3vtm;

		/* Vth Calculation */
		T3 = sqrt(Xdep);
		V0 = BSIM3vbi - BSIM3phi;

		T0 = BSIM3dvt2 * Vbseff;
		if (T0 >= - 0.5)
			begin
			T1 = 1.0 + T0;
			T2 = BSIM3dvt2;
			end
		else /* Added to avoid any discontinuity problems caused by dvt2 */ 
			begin   
			T4 = 1.0 / (3.0 + 8.0 * T0);
			T1 = (1.0 + 3.0 * T0) * T4; 
			T2 = BSIM3dvt2 * T4 * T4;
			end

		lt1 = BSIM3factor1 * T3 * T1;
		T0 = BSIM3dvt2w * Vbseff;
		if (T0 >= - 0.5)
			begin
			T1 = 1.0 + T0;
			T2 = BSIM3dvt2w;
			end
		else /* Added to avoid any discontinuity problems caused by dvt2w */ 
			begin  
			T4 = 1.0 / (3.0 + 8.0 * T0);
			T1 = (1.0 + 3.0 * T0) * T4; 
			T2 = BSIM3dvt2w * T4 * T4;
			end

		ltw = BSIM3factor1 * T3 * T1;

		T0 = -0.5 * BSIM3dvt1 * Leff / lt1;
		if (T0 > -`EXP_THRESHOLD)
			begin   
			T1 = exp(T0);
			Theta0 = T1 * (1.0 + 2.0 * T1);
			end
		else 
			begin
			T1 = `MIN_EXP;
			Theta0 = T1 * (1.0 + 2.0 * T1);
			end

		BSIM3thetavth = BSIM3dvt0 * Theta0;
		Delt_vth = BSIM3thetavth * V0;

		T0 = -0.5 * BSIM3dvt1w * BSIM3weff * Leff / ltw;
		if (T0 > -`EXP_THRESHOLD)
			begin
			T1 = exp(T0);
			T2 = T1 * (1.0 + 2.0 * T1);
			end
		else
			begin
			T1 = `MIN_EXP;
			T2 = T1 * (1.0 + 2.0 * T1);
			end

		T0 = BSIM3dvt0w * T2;
		T2 = T0 * V0;

		//FIXME: `CKTtemp should be obtained by $temperature in veriloga
		TempRatio =  `CKTtemp / BSIM3tnom - 1.0;
		T0 = sqrt(1.0 + BSIM3nlx / Leff);
		T1 = BSIM3k1ox * (T0 - 1.0) * BSIM3sqrtPhi
			 + (BSIM3kt1 + BSIM3kt1l / Leff
			 + BSIM3kt2 * Vbseff) * TempRatio;
		tmp2 = BSIM3tox * BSIM3phi/ (BSIM3weff + BSIM3w0);

		T3 = BSIM3eta0 + BSIM3etab * Vbseff;
		if (T3 < 1.0e-4) /* avoid  discontinuity problems caused by etab */ 
			begin  
			T9 = 1.0 / (3.0 - 2.0e4 * T3);
			T3 = (2.0e-4 - T3) * T9;
			T4 = T9 * T9;
			end
		else
			T4 = 1.0;

		dDIBL_Sft_dVd = T3 * BSIM3theta0vb0;
		DIBL_Sft = dDIBL_Sft_dVd * Vds;
		
		Vth = BSIM3type * BSIM3vth0 - BSIM3k1 
			  * BSIM3sqrtPhi + BSIM3k1ox * sqrtPhis
			  - BSIM3k2ox * Vbseff - Delt_vth - T2 + (BSIM3k3
			  + BSIM3k3b * Vbseff) * tmp2 + T1 - DIBL_Sft;

		BSIM3von = Vth; 

		/* Calculate n */
		tmp2 = BSIM3nfactor * `EPSSI / Xdep;
		tmp3 = BSIM3cdsc + BSIM3cdscb * Vbseff+ BSIM3cdscd * Vds;
		tmp4 = (tmp2 + tmp3 * Theta0 + BSIM3cit) / BSIM3cox;
		if (tmp4 >= -0.5)
			n = 1.0 + tmp4;
		else /* avoid  discontinuity problems caused by tmp4 */ 
			begin
			T0 = 1.0 / (3.0 + 8.0 * tmp4);
			n = (1.0 + 3.0 * tmp4) * T0;
			end

		/* Poly Gate Si Depletion Effect */
		T0 = BSIM3vfb + BSIM3phi;
		if ((BSIM3ngate > 1.0e18) && (BSIM3ngate < 1.0e25) && (Vgs > T0))
			begin
			/* added to avoid the problem caused by ngate */
			T1 = 1.0e6 * `Charge_q * `EPSSI * BSIM3ngate/(BSIM3cox * BSIM3cox);
			T4 = sqrt(1.0 + 2.0 * (Vgs - T0) / T1);
			T2 = T1 * (T4 - 1.0);
			T3 = 0.5 * T2 * T2 / T1; /* T3 = Vpoly */
			T7 = 1.12 - T3 - 0.05;
			T6 = sqrt(T7 * T7 + 0.224);
			T5 = 1.12 - 0.5 * (T7 + T6);
			Vgs_eff = Vgs - T5;
			end
		else
			Vgs_eff = Vgs;
		
		Vgst = Vgs_eff - Vth;

		/* Effective Vgst (Vgsteff) Calculation */
		T10 = 2.0 * n * Vtm;
		VgstNVt = Vgst / T10;
		ExpArg = (2.0 * BSIM3voff - Vgst) / T10;

		/* MCJ: Very small Vgst */
		if (VgstNVt > `EXP_THRESHOLD)
			Vgsteff = Vgst;
		else if (ExpArg > `EXP_THRESHOLD)
			begin
			T0 = (Vgst - BSIM3voff) / (n * Vtm);
			ExpVgst = exp(T0);
			Vgsteff = Vtm * BSIM3cdep0 / BSIM3cox * ExpVgst;
			end
		else
			begin
			ExpVgst = exp(VgstNVt);
			T1 = T10 * log(1.0 + ExpVgst);

			dT2_dVg = -BSIM3cox / (Vtm * BSIM3cdep0) * exp(ExpArg);
			T2 = 1.0 - T10 * dT2_dVg;

			Vgsteff = T1 / T2;
			end
			
		BSIM3Vgsteff = Vgsteff;	  

		/* Calculate Effective Channel Geometry */
		T9 = sqrtPhis - BSIM3sqrtPhi;
		Weff = BSIM3weff - 2.0 * (BSIM3dwg * Vgsteff  + BSIM3dwb * T9); 

		if (Weff < 2.0e-8) /* to avoid the discontinuity problem due to Weff*/
		begin
			T0 = 1.0 / (6.0e-8 - 2.0 * Weff);
			Weff = 2.0e-8 * (4.0e-8 - Weff) * T0;
		end
		
		T0 = BSIM3prwg * Vgsteff + BSIM3prwb * T9;
		if (T0 >= -0.9)
			Rds = BSIM3rds0 * (1.0 + T0);
		else
		/* to avoid the discontinuity problem due to prwg and prwb*/
		begin
			T1 = 1.0 / (17.0 + 20.0 * T0);
			Rds = BSIM3rds0 * (0.8 + T0) * T1;
		end
		BSIM3rds = Rds; /* Noise Bugfix */

		/* Calculate Abulk */
		T1 = 0.5 * BSIM3k1ox / sqrtPhis;
		dT1_dVb = -T1 / sqrtPhis * dsqrtPhis_dVb;
		T9 = sqrt(BSIM3xj * Xdep);
		tmp1 = Leff + 2.0 * T9;
		T5 = Leff / tmp1; 
		tmp2 = BSIM3a0 * T5;
		tmp3 = BSIM3weff + BSIM3b1; 
		tmp4 = BSIM3b0 / tmp3;
		T2 = tmp2 + tmp4;
		T6 = T5 * T5;
		T7 = T5 * T6;

		Abulk0 = 1.0 + T1 * T2; 

		T8 = BSIM3ags * BSIM3a0 * T7;
		dAbulk_dVg = -T1 * T8;
		Abulk = Abulk0 + dAbulk_dVg * Vgsteff; 

		if (Abulk0 < 0.1) /* added to avoid the problems caused by Abulk0 */
		begin
			T9 = 1.0 / (3.0 - 20.0 * Abulk0);
			Abulk0 = (0.2 - Abulk0) * T9;
		end

		if (Abulk < 0.1)
		/* added to avoid the problems caused by Abulk */
		begin
			T9 = 1.0 / (3.0 - 20.0 * Abulk);
			Abulk = (0.2 - Abulk) * T9;
		end
		BSIM3Abulk = Abulk;

		T2 = BSIM3keta * Vbseff;
		if (T2 >= -0.9)
			T0 = 1.0 / (1.0 + T2);
		else
		/* added to avoid the problems caused by Keta */
		begin
			T1 = 1.0 / (0.8 + T2);
			T0 = (17.0 + 20.0 * T2) * T1;
		end
		Abulk = Abulk*T0;
		Abulk0= Abulk0*T0;

		/* Mobility calculation */
		if (BSIM3mobMod == 1)
		begin
			T0 = Vgsteff + Vth + Vth;
			T2 = BSIM3ua + BSIM3uc * Vbseff;
			T3 = T0 / BSIM3tox;
			T5 = T3 * (T2 + BSIM3ub * T3);
		end
		else if (BSIM3mobMod == 2)
			T5=Vgsteff/BSIM3tox*(BSIM3ua+BSIM3uc*Vbseff+BSIM3ub*Vgsteff/BSIM3tox);
		else
		begin
			T0 = Vgsteff + Vth + Vth;
			T2 = 1.0 + BSIM3uc * Vbseff;
			T3 = T0 / BSIM3tox;
			T4 = T3 * (BSIM3ua + BSIM3ub * T3);
			T5 = T4 * T2;
		end

		if (T5 >= -0.8)
			Denomi = 1.0 + T5;
		else /* Added to avoid the discontinuity problem caused by ua and ub*/ 
		begin
			T9 = 1.0 / (7.0 + 10.0 * T5);
			Denomi = (0.6 + T5) * T9;
		end
		
		BSIM3ueff=BSIM3u0temp / Denomi;
		ueff=BSIM3ueff;
		/* Saturation Drain Voltage  Vdsat */
		WVCox = Weff * BSIM3vsattemp * BSIM3cox;
		WVCoxRds = WVCox * Rds; 

		Esat = 2.0 * BSIM3vsattemp / ueff;
		EsatL = Esat * Leff;
	  
		/* Sqrt() */
		//a1 = BSIM3a1;
		if (BSIM3a1 == 0.0)
			Lambda = BSIM3a2;
		else if (BSIM3a1 > 0.0)
		/* Added to avoid the discontinuity problem caused by a1 and a2 (Lambda) */
		begin
			T0 = 1.0 - BSIM3a2;
			T1 = T0 - BSIM3a1 * Vgsteff - 0.0001;
			T2 = sqrt(T1 * T1 + 0.0004 * T0);
			Lambda = BSIM3a2 + T0 - 0.5 * (T1 + T2);
		end
		else
		begin
			T1 = BSIM3a2 + BSIM3a1 * Vgsteff - 0.0001;
			T2 = sqrt(T1 * T1 + 0.0004 * BSIM3a2);
			Lambda = 0.5 * (T1 + T2);
		end

		Vgst2Vtm = Vgsteff + 2.0 * Vtm;
		BSIM3AbovVgst2Vtm = Abulk / Vgst2Vtm;
		
		if ((Rds == 0.0) && (Lambda == 1.0))
		begin
			T0 = 1.0 / (Abulk * EsatL + Vgst2Vtm);
			T3 = EsatL * Vgst2Vtm;
			Vdsat = T3 * T0;
		end
		else
		begin
			T9 = Abulk * WVCoxRds;
			T7 = Vgst2Vtm * T9;
			T6 = Vgst2Vtm * WVCoxRds;
			T0 = 2.0 * Abulk * (T9 - 1.0 + 1.0 / Lambda); 
			T1 = Vgst2Vtm * (2.0 / Lambda - 1.0) + Abulk * EsatL + 3.0 * T7;
			T2 = Vgst2Vtm * (EsatL + 2.0 * T6);
			T3 = sqrt(T1 * T1 - 2.0 * T0 * T2);
			Vdsat = (T1 - T3) / T0;
		end
		BSIM3vdsat = Vdsat;

		/* Effective Vds (Vdseff) Calculation */
		T1 = Vdsat - Vds - BSIM3delta;
		T2 = sqrt(T1 * T1 + 4.0 * BSIM3delta * Vdsat);
		Vdseff = Vdsat - 0.5 * (T1 + T2);
		
		/* Added to eliminate non-zero Vdseff at Vds=0.0 */
		if (Vds == 0.0)
			Vdseff = 0.0;

		/* Calculate VAsat */
		tmp4 = 1.0 - 0.5 * Abulk * Vdsat / Vgst2Vtm;
		T9 = WVCoxRds * Vgsteff;
		T0 = EsatL + Vdsat + 2.0 * T9 * tmp4;
		T9 = WVCoxRds * Abulk; 
		T1 = 2.0 / Lambda - 1.0 + T9; 
		Vasat = T0 / T1;
		
		if (Vdseff > Vds)
			Vdseff = Vds;
		diffVds = Vds - Vdseff;
		BSIM3Vdseff = Vdseff;  

		/* Calculate VACLM */
		if ((BSIM3pclm > 0.0) && (diffVds > 1.0e-10))
		begin
			T0 = 1.0 / (BSIM3pclm * Abulk * BSIM3litl);
			T2 = Vgsteff / EsatL;
			T1 = Leff * (Abulk + T2); 
			T9 = T0 * T1;
			VACLM = T9 * diffVds;
		end
		else
			VACLM = `MAX_EXP;

		/* Calculate VADIBL */
		if (BSIM3thetaRout > 0.0)
		begin
			T8 = Abulk * Vdsat;
			T0 = Vgst2Vtm * T8;
			T1 = Vgst2Vtm + T8;
			T2 = BSIM3thetaRout;
			VADIBL = (Vgst2Vtm - T0 / T1) / T2;
			T7 = BSIM3pdiblb * Vbseff;
			if (T7 >= -0.9)
			begin
				T3 = 1.0 / (1.0 + T7);
				VADIBL = VADIBL*T3;
			end
			else
			/* Added to avoid the discontinuity problem caused by pdiblcb */
			begin
				T4 = 1.0 / (0.8 + T7);
				T3 = (17.0 + 20.0 * T7) * T4;
				VADIBL = VADIBL * T3;
			end
		end
		else
			VADIBL = `MAX_EXP;

		/* Calculate VA */
		T8 = BSIM3pvag / EsatL;
		T9 = T8 * Vgsteff;
		if (T9 > -0.9)
			T0 = 1.0 + T9;
		else /* Added to avoid the discontinuity problems caused by pvag */
		begin
			T1 = 1.0 / (17.0 + 20.0 * T9);
			T0 = (0.8 + T9) * T1;
		end
		tmp3 = VACLM + VADIBL;
		T1 = VACLM * VADIBL / tmp3;
		Va = Vasat + T0 * T1;

		/* Calculate VASCBE */
		if (BSIM3pscbe2 > 0.0)
		begin
			if (diffVds > BSIM3pscbe1 * BSIM3litl/ `EXP_THRESHOLD)
			begin
				T0 =  BSIM3pscbe1 * BSIM3litl / diffVds;
				VASCBE = Leff * exp(T0) / BSIM3pscbe2;
				T1 = T0 * VASCBE / diffVds;
			end
			else
				VASCBE = `MAX_EXP * Leff/BSIM3pscbe2;
		end
		else
			VASCBE = `MAX_EXP;

		/* Calculate Ids */
		CoxWovL =BSIM3cox * Weff / Leff;
		beta = ueff * CoxWovL;

		T0 = 1.0 - 0.5 * Abulk * Vdseff / Vgst2Vtm;
		fgche1 = Vgsteff * T0;
		T9 = Vdseff / EsatL;
		fgche2 = 1.0 + T9;
	 
		gche = beta * fgche1 / fgche2;
		T0 = 1.0 + gche * Rds;
		T9 = Vdseff / T0;
		Idl = gche * T9;

		T9 =  diffVds / Va;
		T0 =  1.0 + T9;
		Idsa = Idl * T0;

		T9 = diffVds / VASCBE;
		T0 = 1.0 + T9;
		Ids = Idsa * T0;

		/* Substrate current begins */
		tmp = BSIM3alpha0 + BSIM3alpha1 * Leff;
		if ((tmp <= 0.0) || (BSIM3beta0 <= 0.0))
			Isub = 0.0;
		else
		begin
			T2 = tmp / Leff;
			if (diffVds > BSIM3beta0 / `EXP_THRESHOLD)
			begin
				T0 = -BSIM3beta0 / diffVds;
				T1 = T2 * diffVds * exp(T0);
			end
			else
			begin
				T3 = T2 * `MIN_EXP;
				T1 = T3 * diffVds;
			end
			Isub = T1 * Idsa;
			
		end
	 
		//cdrain=Ids;

		////////////////////////////////////////////////////
		//
		// BSIM3 charge calculation begins (section 3)
		//
		///////////////////////////////////////////////////

		/* BSIM3 thermal noise Qinv calculated from all capMod 
		* 0, 1, 2 & 3 stored in here->BSIM3qinv 1/1998 */
		if (BSIM3xpart < 0) 
		begin
			qgate=0.0;
			qdrn =0.0;
			qsrc =0.0;
			qbulk=0.0;
		end
		else if (BSIM3capMod == 0)
		begin
			if (Vbseff < 0.0)
				Vbseff = Vbs;
			else
				Vbseff = BSIM3phi - Phis;
			Vfb = BSIM3vfbcv;
			Vth = Vfb + BSIM3phi + BSIM3k1ox * sqrtPhis; 
			Vgst = Vgs_eff - Vth;
			CoxWL = BSIM3cox * BSIM3weffCV * BSIM3leffCV;
			Arg1 = Vgs_eff - Vbseff - Vfb;

			if (Arg1 <= 0.0)
			begin
				qgate = CoxWL * Arg1;
				qbulk = -qgate;
				qdrn = 0.0;
			end
			else if (Vgst <= 0.0)
			begin
				T1 = 0.5 * BSIM3k1ox;
				T2 = sqrt(T1 * T1 + Arg1);
				qgate = CoxWL * BSIM3k1ox * (T2 - T1);
				qbulk = -qgate;
				qdrn = 0.0;
				
			end
			else
			begin
				One_Third_CoxWL = CoxWL / 3.0;
				Two_Third_CoxWL = 2.0 * One_Third_CoxWL;

				AbulkCV = Abulk0 * BSIM3abulkCVfactor;
				Vdsat = Vgst / AbulkCV;

				if (BSIM3xpart > 0.5)
				begin
					/* 0/100 Charge partition model */
					if (Vdsat <= Vds)
					begin   
						/* saturation region */
						T1 = Vdsat / 3.0;
						qgate = CoxWL * (Vgs_eff - Vfb - BSIM3phi - T1);
						T2 = -Two_Third_CoxWL * Vgst;
						qbulk = -(qgate + T2);
						qdrn = 0.0;
					end
					else
					begin
						/* linear region */
						Alphaz = Vgst / Vdsat;
						T1 = 2.0 * Vdsat - Vds;
						T2 = Vds / (3.0 * T1);
						T3 = T2 * Vds;
						T9 = 0.25 * CoxWL;
						T4 = T9 * Alphaz;
						T7 = 2.0 * Vds - T1 - 3.0 * T3;
						T8 = T3 - T1 - 2.0 * Vds;
						qgate=CoxWL*(Vgs_eff-Vfb-BSIM3phi - 0.5 * (Vds - T3));
						T10 = T4 * T8;
						qdrn = T4 * T7;
						qbulk = -(qgate + qdrn + T10);
						
					end
				end
				else if (BSIM3xpart < 0.5)
				begin   
					/* 40/60 Charge partition model */
					if (Vds >= Vdsat)
					begin   
						/* saturation region */
						T1 = Vdsat / 3.0;
						qgate = CoxWL * (Vgs_eff - Vfb - BSIM3phi - T1);
						T2 = -Two_Third_CoxWL * Vgst;
						qbulk = -(qgate + T2);
						qdrn = 0.4 * T2;
					end
					else
					begin   
						/* linear region  */
						Alphaz = Vgst / Vdsat;
						T1 = 2.0 * Vdsat - Vds;
						T2 = Vds / (3.0 * T1);
						T3 = T2 * Vds;
						T9 = 0.25 * CoxWL;
						T4 = T9 * Alphaz;
						qgate=CoxWL*(Vgs_eff - Vfb - BSIM3phi - 0.5 * (Vds - T3));
						T6=8.0*Vdsat * Vdsat - 6.0 * Vdsat * Vds + 1.2 * Vds * Vds;
						T8 = T2 / T1;
						T7 = Vds - T1 - T8 * T6;
						qdrn = T4 * T7;
				  
						T7 = 2.0 * (T1 + T3);
						qbulk = -(qgate - T4 * T7);
				  
					end
				end
				else
				begin
					/* 50/50 partitioning */
					if (Vds >= Vdsat)
					begin   
						/* saturation region */
						T1 = Vdsat / 3.0;
						qgate = CoxWL * (Vgs_eff - Vfb - BSIM3phi - T1);
						T2 = -Two_Third_CoxWL * Vgst;
						qbulk = -(qgate + T2);
						qdrn = 0.5 * T2;

					end
					else
					begin
						/* linear region */
						Alphaz = Vgst / Vdsat;
						T1 = 2.0 * Vdsat - Vds;
						T2 = Vds / (3.0 * T1);
						T3 = T2 * Vds;
						T9 = 0.25 * CoxWL;
						T4 = T9 * Alphaz;
						qgate =CoxWL*(Vgs_eff-Vfb - BSIM3phi - 0.5 * (Vds - T3));
						
						T7 = T1 + T3;
						qdrn = -T4 * T7;
						qbulk = - (qgate + qdrn + qdrn);
						
					end
				end
			end
		end //if (BSIM3capMod == 0)
		else	//BSIM3capMod !=0
		begin   
			if (Vbseff < 0.0)
				VbseffCV = Vbseff;
			else
				VbseffCV = BSIM3phi - Phis;

			CoxWL = BSIM3cox * BSIM3weffCV * BSIM3leffCV;

			/* Seperate VgsteffCV with noff and voffcv */
			LOCAL_noff = n * BSIM3noff;
			T0 = Vtm * LOCAL_noff;
			LOCAL_voffcv = BSIM3voffcv;
			VgstNVt = (Vgst - LOCAL_voffcv) / T0;

			if (VgstNVt > `EXP_THRESHOLD)
				Vgsteff = Vgst - LOCAL_voffcv;
			else if (VgstNVt < -`EXP_THRESHOLD)
				Vgsteff = T0 * log(1.0 + `MIN_EXP);
			else
			begin
				ExpVgst = exp(VgstNVt);
				Vgsteff = T0 * log(1.0 + ExpVgst);
			end /* End of VgsteffCV */
			
			if (BSIM3capMod == 1)
			begin
				Vfb = BSIM3vfbzb;
				Arg1 = Vgs_eff - VbseffCV - Vfb - Vgsteff;

				if (Arg1 <= 0.0)
					qgate = CoxWL * Arg1;
				else
				begin
					T0 = 0.5 * BSIM3k1ox;
					T1 = sqrt(T0 * T0 + Arg1);
				  
					qgate = CoxWL * BSIM3k1ox * (T1 - T0);
				end
				qbulk = -qgate;

				One_Third_CoxWL = CoxWL / 3.0;
				Two_Third_CoxWL = 2.0 * One_Third_CoxWL;
				AbulkCV = Abulk0 * BSIM3abulkCVfactor;
				VdsatCV = Vgsteff / AbulkCV;
				if (VdsatCV < Vds)
				begin
					T0 = Vgsteff - VdsatCV / 3.0;
					qgate = qgate+ CoxWL * T0;

					T0 = VdsatCV - Vgsteff;
					qbulk =qgate+ One_Third_CoxWL * T0;

					if (BSIM3xpart > 0.5)
						T0 = -Two_Third_CoxWL;
					else if (BSIM3xpart < 0.5)
						T0 = -0.4 * CoxWL;
					else
						T0 = -One_Third_CoxWL;
					qsrc = T0 * Vgsteff;
				end
				else
				begin
					T0 = AbulkCV * Vds;
					T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1.0e-20);
					T2 = Vds / T1;
					T3 = T0 * T2;
					qgate =qgate+ CoxWL * (Vgsteff - 0.5 * Vds + T3);
					qbulk = qgate +CoxWL * (1.0 - AbulkCV) * (0.5 * Vds - T3);
					if (BSIM3xpart > 0.5)
					begin
						/* 0/100 Charge petition model */
						T1 = T1 + T1;
						qsrc = -CoxWL * (0.5 * Vgsteff + 0.25 * T0 - T0 * T0 / T1);
					end
					else if (BSIM3xpart < 0.5)
					begin
						/* 40/60 Charge petition model */
						T1 = T1 / 12.0;
						T2 = 0.5 * CoxWL / (T1 * T1);
						T3 = Vgsteff * (2.0 * T0 * T0 / 3.0 + Vgsteff
							* (Vgsteff - 4.0 * T0 / 3.0))
							- 2.0 * T0 * T0 * T0 / 15.0;
						qsrc = -T2 * T3;
					end
					else /* 50/50 Charge petition model */
						qsrc = -0.5 * (qgate + qbulk);
				end
				qdrn = -(qgate + qbulk + qsrc);
			end
			else if (BSIM3capMod == 2)
			begin
				Vfb = BSIM3vfbzb;
				V3 = Vfb - Vgs_eff + VbseffCV - `DELTA_3;
				if (Vfb <= 0.0)
					T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfb);
				else
					T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfb);
				Vfbeff = Vfb - 0.5 * (V3 + T0);
				Qac0 = CoxWL * (Vfbeff - Vfb);

				T0 = 0.5 * BSIM3k1ox;
				T3 = Vgs_eff - Vfbeff - VbseffCV - Vgsteff;
				if (BSIM3k1ox == 0.0)
					T1 = 0.0;
				else if (T3 < 0.0)
					T1 = T0 + T3 / BSIM3k1ox;
				else
					T1 = sqrt(T0 * T0 + T3);
				Qsub0 = CoxWL * BSIM3k1ox * (T1 - T0);
				AbulkCV = Abulk0 * BSIM3abulkCVfactor;
				VdsatCV = Vgsteff / AbulkCV;

				V4 = VdsatCV - Vds - `DELTA_4;
				T0 = sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV);
				VdseffCV = VdsatCV - 0.5 * (V4 + T0);
				
				/* Added to eliminate non-zero VdseffCV at Vds=0.0 */
				if (Vds == 0.0)
					VdseffCV = 0.0;

				T0 = AbulkCV * VdseffCV;
				T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1e-20);
				T2 = VdseffCV / T1;
				T3 = T0 * T2;
				//ningd: what's qinoi, for noise model?
				qinoi = -CoxWL * (Vgsteff - 0.5 * T0 + AbulkCV * T3);
				qgate = CoxWL * (Vgsteff - 0.5 * VdseffCV + T3);
				T7 = 1.0 - AbulkCV;
				qbulk = CoxWL * T7 * (0.5 * VdseffCV - T3);
				
				if (BSIM3xpart > 0.5)
				begin   
					/* 0/100 Charge petition model */
					T1 = T1 + T1;
					qsrc = -CoxWL * (0.5 * Vgsteff + 0.25 * T0 - T0 * T0 / T1);
				end
				else if (BSIM3xpart < 0.5)
				begin   
					/* 40/60 Charge petition model */
					T1 = T1 / 12.0;
					T2 = 0.5 * CoxWL / (T1 * T1);
					T3 = Vgsteff * (2.0 * T0 * T0 / 3.0 + Vgsteff
						* (Vgsteff - 4.0 * T0 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
					qsrc = -T2 * T3;
				end
				else /* 50/50 Charge petition model */
					qsrc = -0.5 * (qgate + qbulk);
				
				qgate =qgate+ Qac0 + Qsub0;
				qbulk =qbulk- (Qac0 + Qsub0);
				qdrn = -(qgate + qbulk + qsrc);
				
				
				//TODO: find out what is qinoi
				BSIM3qinv = qinoi;
			end
			/* New Charge-Thickness capMod (CTM) begins */
			else if (BSIM3capMod == 3)
			begin
				V3 = BSIM3vfbzb - Vgs_eff + VbseffCV - `DELTA_3;
				if (BSIM3vfbzb <= 0.0)
					T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * BSIM3vfbzb);
				else
					T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * BSIM3vfbzb);
				Vfbeff = BSIM3vfbzb - 0.5 * (V3 + T0);

				Cox = BSIM3cox;
				Tox = 1.0e8 * BSIM3tox;
				T0 = (Vgs_eff - VbseffCV - BSIM3vfbzb) / Tox;

				tmp = T0 * BSIM3acde;
				if ((-`EXP_THRESHOLD < tmp) && (tmp < `EXP_THRESHOLD))
					Tcen = BSIM3ldeb * exp(tmp);
				else if (tmp <= -`EXP_THRESHOLD)
					Tcen = BSIM3ldeb * `MIN_EXP;
				else
					Tcen = BSIM3ldeb * `MAX_EXP;
				
				LINK = 1.0e-3 * BSIM3tox;
				V3 = BSIM3ldeb - Tcen - LINK;
				V4 = sqrt(V3 * V3 + 4.0 * LINK * BSIM3ldeb);
				Tcen = BSIM3ldeb - 0.5 * (V3 + V4);
				Ccen = `EPSSI / Tcen;
				T2 = Cox / (Cox + Ccen);
				Coxeff = T2 * Ccen;
				CoxWLcen = CoxWL * Coxeff / Cox;
				
				Qac0 = CoxWLcen * (Vfbeff - BSIM3vfbzb);
				T0 = 0.5 * BSIM3k1ox;
				T3 = Vgs_eff - Vfbeff - VbseffCV - Vgsteff;
				if (BSIM3k1ox == 0.0)
					T1 = 0.0;
				else if (T3 < 0.0)
					T1 = T0 + T3 / BSIM3k1ox;
				else
					T1 = sqrt(T0 * T0 + T3);

				Qsub0 = CoxWLcen * BSIM3k1ox * (T1 - T0);

				/* Gate-bias dependent delta Phis begins */
				if (BSIM3k1ox <= 0.0)
				begin   
					Denomi = 0.25 * BSIM3moin * Vtm;
					T0 = 0.5 * BSIM3sqrtPhi;
				end
				else
				begin   
					Denomi = BSIM3moin * Vtm * BSIM3k1ox * BSIM3k1ox;
					T0 = BSIM3k1ox * BSIM3sqrtPhi;
				end
				T1 = 2.0 * T0 + Vgsteff;
				DeltaPhi = Vtm * log(1.0 + T1 * Vgsteff / Denomi);
				/* End of delta Phis */

				T3 = 4.0 * (Vth - BSIM3vfbzb - BSIM3phi);
				Tox = Tox + Tox;
				
				if (T3 >= 0.0)
					T0 = (Vgsteff + T3) / Tox;
				else
					T0 = (Vgsteff + 1.0e-20) / Tox;
				tmp = exp(0.7 * log(T0));
				T1 = 1.0 + tmp;
				Tcen = 1.9e-9 / T1;
				Ccen = `EPSSI / Tcen;
				T0 = Cox / (Cox + Ccen);
				Coxeff = T0 * Ccen;
				CoxWLcen = CoxWL * Coxeff / Cox;

				AbulkCV = Abulk0 * BSIM3abulkCVfactor;
				VdsatCV = (Vgsteff - DeltaPhi) / AbulkCV;
				V4 = VdsatCV - Vds - `DELTA_4;
				T0 = sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV);
				VdseffCV = VdsatCV - 0.5 * (V4 + T0);
				T1 = 0.5 * (1.0 + V4 / T0);
				
				/* Added to eliminate non-zero VdseffCV at Vds=0.0 */
				if (Vds == 0.0)
					VdseffCV = 0.0;
				
				T0 = AbulkCV * VdseffCV;
				T1 = Vgsteff - DeltaPhi;
				T2 = 12.0 * (T1 - 0.5 * T0 + 1.0e-20);
				T3 = T0 / T2;
				T4 = 1.0 - 12.0 * T3 * T3;
				T5 = AbulkCV * (6.0 * T0 * (4.0 * T1 - T0) / (T2 * T2) - 0.5);
				T6 = T5 * VdseffCV / AbulkCV;

				qgate = CoxWLcen * (T1 - T0 * (0.5 - T3));
				qinoi = qgate;	
				T7 = 1.0 - AbulkCV;
				qbulk = CoxWLcen * T7 * (0.5 * VdseffCV - T0 * VdseffCV / T2);
				if (BSIM3xpart > 0.5)
					/* 0/100 partition */
					qsrc = -CoxWLcen * (T1 / 2.0 + T0 / 4.0 - 0.5 * T0 * T0 / T2);
				else if (BSIM3xpart < 0.5)
				begin
					/* 40/60 partition */
					T2 = T2 / 12.0;
					T3 = 0.5 * CoxWLcen / (T2 * T2);
					T4 = T1 * (2.0 * T0 * T0 / 3.0 + T1 * (T1 - 4.0 
							 * T0 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
					qsrc = -T3 * T4;
				end
				else
					/* 50/50 partition */
					qsrc = -0.5 * qgate;

				qgate =qgate+ Qac0 + Qsub0 - qbulk;
				qbulk =qbulk- (Qac0 + Qsub0);
				qdrn = -(qgate + qbulk + qsrc);
				
				//TODO: what is qinoi
				BSIM3qinv = -qinoi;
			end  /* End of CTM */
		end

		/*  charge storage elements
				   *  bulk-drain and bulk-source depletion capacitances
				   *  czbd : zero bias drain junction capacitance
				   *  czbs : zero bias source junction capacitance
				   *  czbdsw: zero bias drain junction sidewall capacitance
				  along field oxide
				   *  czbssw: zero bias source junction sidewall capacitance
				  along field oxide
			   *  czbdswg: zero bias drain junction sidewall capacitance
				   along gate side
			   *  czbsswg: zero bias source junction sidewall capacitance
				   along gate side
		*/
		
		czbd = BSIM3unitAreaTempJctCap * BSIM3drainArea; /*bug fix */
		czbs = BSIM3unitAreaTempJctCap * BSIM3sourceArea;
		
		if (BSIM3drainPerimeter < BSIM3weff)
		begin 
			czbdswg = BSIM3unitLengthGateSidewallTempJctCap * BSIM3drainPerimeter;
			czbdsw = 0.0;
		end
		else
		begin
			czbdsw=BSIM3unitLengthSidewallTempJctCap*(BSIM3drainPerimeter - BSIM3weff);
			czbdswg = BSIM3unitLengthGateSidewallTempJctCap *  BSIM3weff;
		end

		if (BSIM3sourcePerimeter < BSIM3weff)
		begin
			czbssw = 0.0; 
			czbsswg = BSIM3unitLengthGateSidewallTempJctCap * BSIM3sourcePerimeter;
		end
		else
		begin
			czbssw=BSIM3unitLengthSidewallTempJctCap*(BSIM3sourcePerimeter - BSIM3weff);
			czbsswg = BSIM3unitLengthGateSidewallTempJctCap *  BSIM3weff;
		end

		MJ = BSIM3bulkJctBotGradingCoeff;
		MJSW = BSIM3bulkJctSideGradingCoeff;
		MJSWG = BSIM3bulkJctGateSideGradingCoeff;

		/* Source Bulk Junction */
		//TODO/FIXME: use a flag to turn on/off this part of code
		if (vbs == 0.0)
			//	*(ckt->CKTstate0 + BSIM3qbs) = 0.0;
			BSIM3qbs = 0.0;
		else if (vbs < 0.0)
		begin
			if (czbs > 0.0)
			begin
				arg = 1.0 - vbs / BSIM3PhiB;
				if (MJ == 0.5)
					sarg = 1.0 / sqrt(arg);
				else
					sarg = exp(-MJ * log(arg));

				BSIM3qbs = BSIM3PhiB * czbs * (1.0 - arg * sarg) / (1.0 - MJ);
			end
			else
				//*(ckt->CKTstate0 + BSIM3qbs) = 0.0;
				BSIM3qbs = 0.0;

			if (czbssw > 0.0)
			begin
				arg = 1.0 - vbs / BSIM3PhiBSW;
				if (MJSW == 0.5)
					sarg = 1.0 / sqrt(arg);
				else
					sarg = exp(-MJSW * log(arg));
				BSIM3qbs=BSIM3qbs+BSIM3PhiBSW*czbssw*(1.0-arg*sarg)/(1.0-MJSW);
			end

			if (czbsswg > 0.0)
			begin
				arg = 1.0 - vbs / BSIM3PhiBSWG;
				if (MJSWG == 0.5)
					sarg = 1.0 / sqrt(arg);
				else
					sarg = exp(-MJSWG * log(arg));
					BSIM3qbs=BSIM3qbs+BSIM3PhiBSWG*czbsswg*(1.0-arg*sarg)/(1.0-MJSWG);
			end
		end
		else
		begin
			T0 = czbs + czbssw + czbsswg;
			T1 = vbs * (czbs * MJ / BSIM3PhiB + czbssw * MJSW 
				/ BSIM3PhiBSW + czbsswg * MJSWG / BSIM3PhiBSWG);    
			BSIM3qbs = vbs * (T0 + 0.5 * T1);
		end

		/* Drain Bulk Junction */
		//TODO/FIXME: use a flag to turn on/off this part code
		if (vbd == 0.0)
			BSIM3qbd = 0.0;
		else if (vbd < 0.0)
		begin
			if (czbd > 0.0)
			begin
				arg = 1.0 - vbd / BSIM3PhiB;
				if (MJ == 0.5)
					sarg = 1.0 / sqrt(arg);
				else
					sarg = exp(-MJ * log(arg));
				BSIM3qbd = BSIM3PhiB * czbd * (1.0 - arg * sarg) / (1.0 - MJ);
			end
			else
				BSIM3qbd = 0.0;

			if (czbdsw > 0.0)
			begin   
				arg = 1.0 - vbd / BSIM3PhiBSW;
				if (MJSW == 0.5)
					sarg = 1.0 / sqrt(arg);
				else
					sarg = exp(-MJSW * log(arg));
				BSIM3qbd=BSIM3qbd+BSIM3PhiBSW*czbdsw*(1.0-arg*sarg) / (1.0 - MJSW);
			end

			if (czbdswg > 0.0)
			begin
				arg = 1.0 - vbd / BSIM3PhiBSWG;
				if (MJSWG == 0.5)
					sarg = 1.0 / sqrt(arg);
				else
					sarg = exp(-MJSWG * log(arg));
				BSIM3qbd=BSIM3qbd+BSIM3PhiBSWG*czbdswg*(1.0-arg*sarg)/(1.0 - MJSWG);
			end
		end
		else
		begin
			T0 = czbd + czbdsw + czbdswg;
			T1 =vbd*(czbd*MJ/BSIM3PhiB+czbdsw*MJSW
					/BSIM3PhiBSW+czbdswg*MJSWG/BSIM3PhiBSWG);
			BSIM3qbd = vbd * (T0 + 0.5 * T1);
		end
		 
		 /* NQS begins */
		//TODO/FIXME: take care nqs model later
		/*
		if (here->BSIM3nqsMod)
			  begin   qcheq = -(qbulk + qgate);

				  here->BSIM3cqgb = -(here->BSIM3cggb + here->BSIM3cbgb);
				  here->BSIM3cqdb = -(here->BSIM3cgdb + here->BSIM3cbdb);
				  here->BSIM3cqsb = -(here->BSIM3cgsb + here->BSIM3cbsb);
				  here->BSIM3cqbb = -(here->BSIM3cqgb + here->BSIM3cqdb
								  + here->BSIM3cqsb);

				  gtau_drift = fabs(pParam->BSIM3tconst * qcheq) * ScalingFactor;
				  T0 = pParam->BSIM3leffCV * pParam->BSIM3leffCV;
				  gtau_diff = 16.0 * pParam->BSIM3u0temp * model->BSIM3vtm / T0
				* ScalingFactor;
				  here->BSIM3gtau =  gtau_drift + gtau_diff;
			  end
		*/
		
		if (BSIM3capMod == 0) /* code merge -JX */
		begin
			LOCAL_cgdo = BSIM3cgdo;
			qgdo = BSIM3cgdo * vgd;
			LOCAL_cgso = BSIM3cgso;
			qgso = BSIM3cgso * vgs;
		end
		if (BSIM3capMod == 1)
		begin
			if (vgd < 0.0)
			begin
				T1 = sqrt(1.0 - 4.0 * vgd / BSIM3ckappa);
				LOCAL_cgdo = BSIM3cgdo + BSIM3weffCV * BSIM3cgdl / T1;
				qgdo=BSIM3cgdo*vgd-BSIM3weffCV*0.5*BSIM3cgdl*BSIM3ckappa*(T1 - 1.0);
			end
			else
			begin
				LOCAL_cgdo = BSIM3cgdo + BSIM3weffCV * BSIM3cgdl;
				qgdo = (BSIM3weffCV * BSIM3cgdl + BSIM3cgdo) * vgd;
			end
			if (vgs < 0.0)
			begin
				T1 = sqrt(1.0 - 4.0 * vgs / BSIM3ckappa);
				LOCAL_cgso = BSIM3cgso + BSIM3weffCV * BSIM3cgsl / T1;
				qgso=BSIM3cgso*vgs-BSIM3weffCV*0.5*BSIM3cgsl*BSIM3ckappa*(T1 - 1.0);
			end
			else
			begin
				LOCAL_cgso = BSIM3cgso + BSIM3weffCV * BSIM3cgsl;
				qgso = (BSIM3weffCV * BSIM3cgsl + BSIM3cgso) * vgs;
			end
		end
		else
		begin
			T0 = vgd + `DELTA_1;
			T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
			T2 = 0.5 * (T0 - T1);

			T3 = BSIM3weffCV * BSIM3cgdl;
			T4 = sqrt(1.0 - 4.0 * T2 / BSIM3ckappa);
			LOCAL_cgdo = BSIM3cgdo + T3 - T3 * (1.0 - 1.0 / T4)*(0.5 - 0.5 * T0 / T1);
			qgdo=(BSIM3cgdo + T3) * vgd - T3 * (T2 + 0.5 * BSIM3ckappa * (T4 - 1.0));

			T0 = vgs + `DELTA_1;
			T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
			T2 = 0.5 * (T0 - T1);
			T3 = BSIM3weffCV * BSIM3cgsl;
			T4 = sqrt(1.0 - 4.0 * T2 / BSIM3ckappa);
			LOCAL_cgso=BSIM3cgso+T3 - T3 * (1.0 - 1.0 / T4) * (0.5 - 0.5 * T0 / T1);
			qgso=(BSIM3cgso+T3)*vgs-T3*(T2+0.5*BSIM3ckappa*(T4 - 1.0));
		end

		BSIM3cgdo = LOCAL_cgdo;
		BSIM3cgso = LOCAL_cgso;

		if (BSIM3mode > 0)
		begin
			if (BSIM3nqsMod == 0)
			begin
				qgd = qgdo;
				qgs = qgso;
				qgb = BSIM3cgbo * vgb;
				qgate =qgate+ qgd + qgs + qgb;
				qbulk =qbulk- qgb;
				qdrn =qdrn- qgd;
				qsrc = -(qgate + qbulk + qdrn);

			end
			else
			begin	//TODO/FIXME: take care nqs mode later
				/*
				if (qcheq > 0.0)
						  T0 = BSIM3tconst * qdef * ScalingFactor;
					  else
						  T0 = -BSIM3tconst * qdef * ScalingFactor;
					  ggtg = BSIM3gtg = T0 * BSIM3cqgb;
					  ggtd = BSIM3gtd = T0 * BSIM3cqdb;
					  ggts = BSIM3gts = T0 * BSIM3cqsb;
					  ggtb = BSIM3gtb = T0 * BSIM3cqbb;
			  gqdef = ScalingFactor * ag0;

					  gcqgb = BSIM3cqgb * ag0;
					  gcqdb = BSIM3cqdb * ag0;
					  gcqsb = BSIM3cqsb * ag0;
					  gcqbb = BSIM3cqbb * ag0;

					  gcggb = (cgdo + cgso + BSIM3cgbo ) * ag0;
					  gcgdb = -cgdo * ag0;
					  gcgsb = -cgso * ag0;

					  gcdgb = -cgdo * ag0;
					  gcddb = (BSIM3capbd + cgdo) * ag0;
					  gcdsb = 0.0;

					  gcsgb = -cgso * ag0;
					  gcsdb = 0.0;
					  gcssb = (BSIM3capbs + cgso) * ag0;

					  gcbgb = -BSIM3cgbo * ag0;
					  gcbdb = -BSIM3capbd * ag0;
					  gcbsb = -BSIM3capbs * ag0;

			  CoxWL = model->BSIM3cox * BSIM3weffCV
							* BSIM3leffCV;
			  if (fabs(qcheq) <= 1.0e-5 * CoxWL)
			  begin   if (model->BSIM3xpart < 0.5)
				  begin   dxpart = 0.4;
				  end
				  else if (model->BSIM3xpart > 0.5)
				  begin   dxpart = 0.0;
				  end
				  else
				  begin   dxpart = 0.5;
				  end
				  ddxpart_dVd = ddxpart_dVg = ddxpart_dVb
					  = ddxpart_dVs = 0.0;
			  end
			  else
			  begin   dxpart = qdrn / qcheq;
				  Cdd = BSIM3cddb;
				  Csd = -(BSIM3cgdb + BSIM3cddb
				  + BSIM3cbdb);
				  ddxpart_dVd = (Cdd - dxpart * (Cdd + Csd)) / qcheq;
				  Cdg = BSIM3cdgb;
				  Csg = -(BSIM3cggb + BSIM3cdgb
				  + BSIM3cbgb);
				  ddxpart_dVg = (Cdg - dxpart * (Cdg + Csg)) / qcheq;

				  Cds = BSIM3cdsb;
				  Css = -(BSIM3cgsb + BSIM3cdsb
				  + BSIM3cbsb);
				  ddxpart_dVs = (Cds - dxpart * (Cds + Css)) / qcheq;

				  ddxpart_dVb = -(ddxpart_dVd + ddxpart_dVg + ddxpart_dVs);
			  end
			  sxpart = 1.0 - dxpart;
			  dsxpart_dVd = -ddxpart_dVd;
			  dsxpart_dVg = -ddxpart_dVg;
			  dsxpart_dVs = -ddxpart_dVs;
			  dsxpart_dVb = -(dsxpart_dVd + dsxpart_dVg + dsxpart_dVs);

					  qgd = qgdo;
					  qgs = qgso;
					  qgb = BSIM3cgbo * vgb;
					  qgate = qgd + qgs + qgb;
					  qbulk = -qgb;
					  qdrn = -qgd;
					  qsrc = -(qgate + qbulk + qdrn);
				 */
			end
		end
		else
		begin
			if (BSIM3nqsMod == 0)
			begin
				qgd = qgdo;
				qgs = qgso;
				qgb = BSIM3cgbo * vgb;
				qgate =qgate+ qgd + qgs + qgb;
				qbulk =qbulk- qgb;
				qsrc = qdrn - qgs;
				qdrn = -(qgate + qbulk + qsrc);

			end
			else
			begin
				//TODO/FIXME: take care nqs model later
				/*
				if (qcheq > 0.0)
						  T0 = pParam->BSIM3tconst * qdef * ScalingFactor;
					  else
						  T0 = -pParam->BSIM3tconst * qdef * ScalingFactor;
					  ggtg = here->BSIM3gtg = T0 * here->BSIM3cqgb;
					  ggts = here->BSIM3gtd = T0 * here->BSIM3cqdb;
					  ggtd = here->BSIM3gts = T0 * here->BSIM3cqsb;
					  ggtb = here->BSIM3gtb = T0 * here->BSIM3cqbb;
			  gqdef = ScalingFactor * ag0;

					  gcqgb = here->BSIM3cqgb * ag0;
					  gcqdb = here->BSIM3cqsb * ag0;
					  gcqsb = here->BSIM3cqdb * ag0;
					  gcqbb = here->BSIM3cqbb * ag0;

					  gcggb = (cgdo + cgso + pParam->BSIM3cgbo) * ag0;
					  gcgdb = -cgdo * ag0;
					  gcgsb = -cgso * ag0;

					  gcdgb = -cgdo * ag0;
					  gcddb = (here->BSIM3capbd + cgdo) * ag0;
					  gcdsb = 0.0;

					  gcsgb = -cgso * ag0;
					  gcsdb = 0.0;
					  gcssb = (here->BSIM3capbs + cgso) * ag0;

					  gcbgb = -pParam->BSIM3cgbo * ag0;
					  gcbdb = -here->BSIM3capbd * ag0;
					  gcbsb = -here->BSIM3capbs * ag0;

			  CoxWL = model->BSIM3cox * pParam->BSIM3weffCV
							* pParam->BSIM3leffCV;
			  if (fabs(qcheq) <= 1.0e-5 * CoxWL)
			  begin   if (model->BSIM3xpart < 0.5)
				  begin   sxpart = 0.4;
				  end
				  else if (model->BSIM3xpart > 0.5)
				  begin   sxpart = 0.0;
				  end
				  else
				  begin   sxpart = 0.5;
				  end
				  dsxpart_dVd = dsxpart_dVg = dsxpart_dVb
					  = dsxpart_dVs = 0.0;
			  end
			  else
			  begin   sxpart = qdrn / qcheq;
				  Css = here->BSIM3cddb;
				  Cds = -(here->BSIM3cgdb + here->BSIM3cddb
				  + here->BSIM3cbdb);
				  dsxpart_dVs = (Css - sxpart * (Css + Cds)) / qcheq;
				  Csg = here->BSIM3cdgb;
				  Cdg = -(here->BSIM3cggb + here->BSIM3cdgb
				  + here->BSIM3cbgb);
				  dsxpart_dVg = (Csg - sxpart * (Csg + Cdg)) / qcheq;

				  Csd = here->BSIM3cdsb;
				  Cdd = -(here->BSIM3cgsb + here->BSIM3cdsb
				  + here->BSIM3cbsb);
				  dsxpart_dVd = (Csd - sxpart * (Csd + Cdd)) / qcheq;

				  dsxpart_dVb = -(dsxpart_dVd + dsxpart_dVg + dsxpart_dVs);
			  end
			  dxpart = 1.0 - sxpart;
			  ddxpart_dVd = -dsxpart_dVd;
			  ddxpart_dVg = -dsxpart_dVg;
			  ddxpart_dVs = -dsxpart_dVs;
			  ddxpart_dVb = -(ddxpart_dVd + ddxpart_dVg + ddxpart_dVs);

					  qgd = qgdo;
					  qgs = qgso;
					  qgb = pParam->BSIM3cgbo * vgb;
					  qgate = qgd + qgs + qgb;
					  qbulk = -qgb;
					  qsrc = -qgs;
					  qdrn = -(qgate + qbulk + qsrc);
				*/
			end
		end

		////////////////////////////////////////////////////
		//
		// BSIM3 charge/current contribution begins (section 4)
		//
		///////////////////////////////////////////////////
		

		//The following code are essentially adopted from concetual BSIM3 DC model 
		//ceqbd=I(b,dp)
		//ceqbs=I(b,sp)
		//cdreq=cdrain=Ids=I(dp,sp)
		
		if (BSIM3mode > 0)
		begin
			cdreq=BSIM3type*Ids;
			ceqbd=-BSIM3type*Isub;	//Isub=BSIM3csub
			ceqbs = 0.0;	//Ibs
		end
		else
		begin
			cdreq=-BSIM3type*Ids;
			ceqbs=-BSIM3type*Isub;
			ceqbd = 0.0;
		end
	
		if (BSIM3type > 0)
		begin
			ceqbs =ceqbs+ BSIM3cbs; 
			ceqbd =ceqbd+ BSIM3cbd;
		end
		else
		begin   
			   ceqbs =ceqbs- BSIM3cbs;
			   ceqbd =ceqbd- BSIM3cbd;
		end

	/*
	(*(ckt->CKTrhs + here->BSIM3gNode) -= ceqqg);
	(*(ckt->CKTrhs + here->BSIM3bNode) -=(ceqbs + ceqbd + ceqqb));
	(*(ckt->CKTrhs + here->BSIM3dNodePrime) += (ceqbd - cdreq - ceqqd));
	(*(ckt->CKTrhs + here->BSIM3sNodePrime) += (cdreq + ceqbs + ceqqg + ceqqb + ceqqd));
	*/
		//DC branch current contribution
		//source/drain resistance
		vd_vdp = V(vd,vdp);
		vs_vsp = V(vs,vsp);
		I(vd, vdp) <+ vd_vdp*BSIM3drainConductance;
		I(vs, vsp) <+ vs_vsp*BSIM3sourceConductance;

		//Ids
		I(vdp, vsp)<+ cdreq;
		//source/drain -  bulk parasitic diodes
		I(vb, vdp) <+ ceqbd;
		I(vb, vsp) <+ ceqbs;

		//charge current distribution
		I(vg, vsp) <+ BSIM3type * ddt(qgate);
		I(vb, vsp) <+ BSIM3type * ddt(qbulk);
		I(vb, vsp) <+ BSIM3type * ddt(BSIM3qbs);
		I(vb, vdp) <+ BSIM3type * ddt(BSIM3qbd);
		I(vdp,vsp) <+ BSIM3type * ddt(qdrn);

		
		//Current Output
		//Igate	+= 0.0;
		//Idrain	+= I_drain_drainp;
		//Isource	+= I_source_sourcep;
		//Ibulk	+= I_bulk_drainp+I_bulk_sourcep;
		//Idrainp	+= I_drainp_sourcep - I_bulk_drainp - I_drain_drainp;
		//Isourcep+= -I_drainp_sourcep - I_bulk_sourcep - I_source_sourcep;

		//Change Output;
		//Qgate	=qgate;
		//Qdrainp	=qdrn-BSIM3qbd;
		//Qbulk	=qbulk+ BSIM3qbd + BSIM3qbs;
		//Qsourcep=-qgate-BSIM3qbs-qbulk-qdrn;
		//Qdrain	=0.0;
		//Qsource	=0.0;

		/*
		BSIM3fprintf("qgate",qgate);
		BSIM3fprintf("qdrn",qdrn);
		BSIM3fprintf("qsrc",qsrc);
		BSIM3fprintf("qbulk",qbulk);
		BSIM3fprintf("qbd",BSIM3qbd);
		BSIM3fprintf("qbs",BSIM3qbs);
		BSIM3fprintf("Ids",Ids);
		BSIM3fprintf("cbd",BSIM3cbd);
		BSIM3fprintf("cbs",BSIM3cbs);
		*/
	end	//analog begin	
endmodule
